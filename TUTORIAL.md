# Bienvenue chez Redwood

Bienvenue chez Redwood! Si vous ne lâ€™avez pas encore fait, prenez le temps de lire [Redwood README](https://github.com/redwoodjs/redwood/blob/main/README.md) pour en savoir un peu plus sur les origines de Redwood et les problÃ¨mes qu'il entend rÃ©soudre. Redwood assemble plusieurs technologies de faÃ§on inÃ©dite et qui correspond Ã  ce que nous pensons Ãªtre le futur des applications web avec base de donnÃ©es.  

Dans ce didacticiel, nous allons construire un moteur de blog. En rÃ©alitÃ©, un blog nâ€™est probablement pas le candidat idÃ©al pour une application construite avec Redwood: les articles peuvent Ãªtre enregistrÃ©s dans un CMS et gÃ©nÃ©rÃ©es statiquement sous la forme de fichiers HTML servis par un CDN. Ceci Ã©tant, la plupart des dÃ©veloppeurs comprennent intuitivement ce que recouvre ce type dâ€™application, et un blog prÃ©sente toutes les caractÃ©ristiques que nous souhaitons mettre en lumiÃ¨re. Nous avons donc dÃ©cidÃ© d'en construire un malgrÃ© tout.

Peut-Ãªtre souhaitez-vous voir ce didacticiel en vidÃ©o? Câ€™est iciÂ :

<div class="relative pb-9/16">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/tiF9SdM1i7M?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

<div class="relative pb-9/16 mt-4">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/SP5vbsWf5Yg?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

<div class="relative pb-9/16 mt-4">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/eT7iIy0F8Tk?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

<div class="relative pb-9/16 mt-4">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/UpD3HyuZkvY?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

## PrÃ©requis

Ce didacticiel suppose que vous soyez dÃ©jÃ  familier avec quelques concepts fondamentauxÂ :

- [React](https://reactjs.org/)
- [GraphQL](https://graphql.org/)
- [The Jamstack](https://jamstack.org/)

Vous pouvez tout Ã  fait complÃ©ter ce didacticiel sans savoir quoique ce soit sur ces technologies, mais il est possible que vous soyez un peu perdu par certains termes que nous utiliserons sans forcÃ©ment les expliquer au prÃ©alable. D'une faÃ§on gÃ©nÃ©rale, il est toujours utile de savoir oÃ¹ se situe les frontiÃ¨res et pouvoir distinguer par exemple ce qui provient de React de ce qui est ajoutÃ© par Redwood. 

### Node.js et Yarn

Pendant lâ€™installation, RedwoodJS commence par verifier si votre systÃ¨me possÃ¨de les versions requises de Node et YarnÂ :

- node: ">=12"
- yarn: ">=1.15"

ğŸ‘‰ **Important:** Si votre systÃ¨me ne repond pas Ã  ces prÃ©requis, _lâ€™installation se soldera par une ERREUR._ VÃ©rifiez en exÃ©cutant les commandes suivantes dans un terminal:

```
node --version
yarn --version
```
ProcÃ©dez aux mises Ã  jour le cas Ã©chÃ©ant, puis relancez lâ€™installation de RedwoodJS lorsque vous Ãªtes prÃªtâ€¯!


> **Installer Node et Yarn**
>
> Il y a diffÃ©rentes faÃ§ons dâ€™installer Node.js et Yarn. Si vous procÃ©dez Ã  leur installation pour la premiÃ¨re fois, nous vous recommandons de suivre les points suivantsÂ :
>
> **Yarn**
>
> - Nous recommandons de suivre les instructions fournies sur [Yarnpkg.com](https://classic.yarnpkg.com/en/docs/install/).
>
> **Node.js**
>
> - Pour les utilisateurs de **Linux** et **Mac**, `nvm` est un excellent outil pour gÃ©rer plusieurs versions de Node sur un mÃªme systÃ¨me. Il demande un petit effort Ã  mettre en place. Dans les deux cas, utiliser la version la plus rÃ©cente de [Nodejs.org](https://nodejs.org/en/) fonctionne trÃ¨s bien.
>   - Pour les utilisateurs de **Mac**, si vous avez dejÃ  installÃ© Homebrew, vous pouvez lâ€™utiliser pour [installer `nvm`](https://formulae.brew.sh/formula/nvm). Dans le cas contraire, suivez les [instructions d'installation pour `nvm`](https://github.com/nvm-sh/nvm#installing-and-updating).
>   - Pour les utilisateurs de **Linux**, vous pouvez suivre les [instructions d'installation pour `nvm`](https://github.com/nvm-sh/nvm#installing-and-updating).
> - Nous recommandons aux utilisateurs de **Windows** de visiter [Nodejs.org](https://nodejs.org/en/) pour savoir comment procÃ©der.
>
> Si vous Ãªtes un peu perdu au moment de choisir quelle version de Node utiliser, nous vous recommandons la plus rÃ©cente LTS avec un numÃ©ro de version pair, actuellement il s'agit de la v12.

## Installation & DÃ©marrage du dÃ©veloppement

Nous utiliserons yarn ([yarn](https://yarnpkg.com/en/docs/install) est un prÃ©-requis) pour crÃ©er la structure de base pour notre applicationÂ :

    yarn create redwood-app ./redwoodblog

Vous obtenez ainsi un nouveau rÃ©pertoire `redwoodblog` contenant plusieurs sous-rÃ©pertoires et fichiers. DÃ©placez-vous dans ce rÃ©pertoire, puis lancez le serveur de dÃ©veloppementÂ :

    cd redwoodblog
    yarn redwood dev

Votre navigateur web devrait se lancer automatiquement et ouvrir `http://localhost:8910` laissant apparaÃ®tre la page dâ€™accueil de Redwood. 

![Redwood Welcome Page](https://user-images.githubusercontent.com/300/73012647-97a43d00-3dcb-11ea-8554-42df29c36e4a.png)

> MÃ©moriser le numÃ©ro de port est trÃ¨s simple, comptez simplement: 8-9-10!

### Premier Commit

Maintenant que nous avons le squelette de notre application Redwood, c'est le bon moment pour enregistrer notre travail avec un premier commit... au cas oÃ¹.

    git init
    git add .
    git commit -m 'Premier commit'

## Structure d'une application Redwood

Examinons maintenant les fichiers et rÃ©pertoires qui ont Ã©tÃ© crÃ©Ã©s pour nous (laissons de cÃ´tÃ© les fichiers de configuration sur lesquels nous reviendrons plus tard)

```terminal
â”œâ”€â”€ api
â”‚   â”œâ”€â”€ prisma
â”‚   â”‚   â”œâ”€â”€ schema.prisma
â”‚   â”‚   â””â”€â”€ seeds.js
â”‚   â””â”€â”€ src
â”‚       â”œâ”€â”€ functions
â”‚       â”‚   â””â”€â”€ graphql.js
â”‚       â”œâ”€â”€ graphql
â”‚       â”œâ”€â”€ lib
â”‚       â”‚   â””â”€â”€ db.js
â”‚       â””â”€â”€ services
â””â”€â”€ web
    â”œâ”€â”€ public
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ favicon.png
    â”‚   â””â”€â”€ robots.txt
    â””â”€â”€ src
        â”œâ”€â”€ Routes.js
        â”œâ”€â”€ components
        â”œâ”€â”€ index.css
        â”œâ”€â”€ index.html
        â”œâ”€â”€ index.js
        â”œâ”€â”€ layouts
        â””â”€â”€ pages
            â”œâ”€â”€ FatalErrorPage
            â”‚   â””â”€â”€ FatalErrorPage.js
            â””â”€â”€ NotFoundPage
                â””â”€â”€ NotFoundPage.js
```
Au premier niveau nous avons deux rÃ©pertoires, `api` et `web`. Redwood sÃ©pare le backend (`api`) et le frontend (`web`) au sein du projet. ([Yarn qualifie cette sÃ©paration de "workspaces"](https://yarnpkg.com/lang/en/docs/workspaces/). Avec Redwood, on fait plutÃ´t rÃ©fÃ©rence aux "cÃ´tÃ©s" web et api de l'application). Ainsi, lorsque plus tard vous serez amenÃ© Ã  ajouter des packages, il vous faudra prÃ©ciser dans quel cÃ´tÃ© ils doivent aller. Par exemple, (inutile d'exÃ©cuter ces commandes):

    yarn workspace web add marked
    yarn workspace api add better-fs

### Le RÃ©pertoire /api

A l'intÃ©rieur du rÃ©pertoire `api` se trouve deux sous-rÃ©pertoires :

- `prisma` contient du code d'infratructure relatif Ã  la base de donnÃ©e

  - `schema.prisma` contient le schÃ©ma de la base de donnÃ©es (ses tables et ses colonnes)
  - `seeds.js` est utilisÃ© pour initialiser la base de donnÃ©es avec les donnÃ©es de base nÃ©cessaire Ã  votre application (utilisateur admin, configuration diverses..).

  Lorsque nous aurons crÃ©Ã© notre premiÃ¨re table dans la base de donnÃ©es, nous trouverons Ã©galement Ã  cet endroit une base de donnÃ©es SQLite sous la forme dâ€™un fichier `dev.db`, ainsi quâ€™un rÃ©pertoire `migrations` contenant des captures successives du schÃ©ma au fil de son Ã©volution.

- `src` contient l'ensemble du code cÃ´tÃ© backend. `api/src` contient quatre rÃ©pertoires supplÃ©mentairesÂ :
  - `functions` contiendra toutes les [fonctions lambda](https://docs.netlify.com/functions/overview/) utilisÃ©es par votre application en plus du fichier `graphql.js` gÃ©nÃ©rÃ© automatiquement par Redwood. Ce dernier fichier est requis pour utiliser une API GraphQL.
  - `graphql` contient votre schÃ©ma GraphQL Ã©crit au format SDL (Schema Definition Language). Les fichiers SDL se terminent par `.sdl.js`.
  - `lib` contient un seul fichier, `db.js`, qui instancie le client Prisma utilisÃ© pour dialoguer avec la base de donnÃ©es. Vous pouvez parfaitement personnaliser ce fichier en ajoutant des options supplÃ©mentaires. Vous pouvez utiliser ce rÃ©pertoire pour tout code relatif au cÃ´tÃ© API de votre application qui ne trouverai pas sa place dans `functions` ou `services`.
  - `services` contient la logique mÃ©tier de votre application. Lorsque vous effectuez une requÃªte ou une mutation de donnÃ©es via GraphQL, ce code se trouve ici dans un format rÃ©utilisable depuis dâ€™autres endroits de votre application.

Et nous en avons terminÃ© avec la partie backend.

### Le rÃ©pertoire /web

- `src` contient plusieurs sous-rÃ©pertoiresÂ :
  - `components` contient vos composants React traditionnels ainsi que les _Cells_ introduites par Redwood (nous y reviendrons bientÃ´t en dÃ©tail).
  - `layouts` contient du code HTML sous forme de composants qui viennent entourer le contenu de votre application et sont partagÃ©s par les diffÃ©rentes _Pages_.
  - `pages` contient des composants souvent insÃ©rÃ©s dans les _Layouts_ et qui constituent les points d'entrÃ©es de votre application pour une URL donnÃ©e (une URL comme `/articles/hello-world` correspondra ainsi Ã  une page tandis que `/contact-us` correspondra Ã  une autre page). Chaque nouvelle application comprend deux pages par dÃ©fautÂ :
    - `NotFoundPage.js` qui est utilisÃ©e lorsquâ€™aucune route nâ€™est trouvÃ©e par le routeur (voir `Routes.js` plus bas).
    - `FatalErrorPage.js` qui est utilisÃ©e lorsquâ€™une erreur survient, quâ€™elle nâ€™a pas Ã©tÃ© gÃ©rÃ©e, et quâ€™il nâ€™est pas possible de poursuivre plus avant sans faire exploser lâ€™application (en gÃ©nÃ©ral il sâ€™agit dâ€™une page blanche).
- `public` contient des ressources non utilisÃ©es par vos composants React (En bout de chaÃ®ne, ces ressources seront copiÃ©es sans Ãªtre modifiÃ©es dans le rÃ©pertoire racine de lâ€™application finale):
  - `favicon.png` est lâ€™icÃ´ne utilisÃ©e par les onglets des navigateurs lorsquâ€™une page est ouverte (par dÃ©faut il sâ€™agit du logo RedwoodJS).
  - `robots.txt` est utilisÃ© pour controller ce que les moteurs de recherche sont [autorisÃ© Ã  indexer](https://www.robotstxt.org/robotstxt.html).
  - `README.md` explique comment, et quand, utiliser le rÃ©pertoire `public` pour vos ressources statiques. Il mentionne Ã©galement les bonnes mÃ©thodes pour importer des ressources Ã  l'intÃ©rieur des composants via Webpack. Vous pouvez Ã©galement lire Ã  ce sujet ce [fichier README.md sur GitHub](https://github.com/redwoodjs/create-redwood-app/tree/main/web/public).
- `index.css` est l'endroit par dÃ©faut oÃ¹ placer vos rÃ¨gles CSS. Il existe cependant dâ€™autres possibilitÃ©s avancÃ©es.
- `index.html` est le point dâ€™entrÃ©e React standard de votre application.
- `index.js` contient le code de dÃ©marrage pour une application Redwood.
- `Routes.js` contient les dÃ©finitions des routes de lâ€™application afin de faire correspondre chaque URL Ã  une _Page_.

## Notre PremiÃ¨re Page

Donnons Ã  nos utilisateurs quelque chose de plus Ã  contempler que la page d'accueil de Redwood. Utilisons la commande `redwood` pour crÃ©er une premiÃ¨re pageÂ :

    yarn redwood generate page home /

Cette commande fait les choses suivantesÂ :

- CrÃ©ation de `web/src/pages/HomePage/HomePage.js`. Redwood prend le nom spÃ©cifiÃ© comme premier argument, le met en majuscules et le suffixe avec "Page" pour construire votre nouveau composant de type Page.
- CrÃ©ation dâ€™un fichier de test du composant `web/src/pages/HomePage/HomePage.test.js` avec un simple test dâ€™exemple Ã  lâ€™intÃ©rieur. Vous Ã©crivez _toujours_ les tests de vos composants, _nâ€™est-ce pasâ€¯??_
- CrÃ©ation dâ€™un fichier Storybook `web/src/pages/HomePage/HomePage.stories.js`. Storybook est un outil formidable pour dÃ©velopper efficacement et organiser vos composants. Si vous souhaitez en savoir plus jetez un oeuil Ã  ce [sujet sur le forum Redwood](https://community.redwoodjs.com/t/how-to-use-the-new-storybook-integration-in-v0-13-0/873) pour apprendre comment lâ€™utiliser.
- Ajout dâ€™une `<Route>` dans `web/src/Routes.js` qui fait correspondre le chemin `/` Ã  la nouvelle page _HomePage_.

> **Import automatique des pages dans le fichier Routes**
>
> Si vous regardez dans Routes, vous constaterez mention d'un composant, `HomePage`, qui n'est prÃ©sent nulle part ailleurs. Redwood importe automatiquement toutes les pages dans le fichier Routes puisque nous aurons besoin de toutes les rÃ©fÃ©rencer de toute faÃ§on. Cela permet de s'Ã©pargner un `import` massif qui viendrait encombrer le fichier Routes.

En rÃ©alitÃ©, cette page est dÃ©jÃ  active (et votre navigateur lâ€™a rechargÃ©e pour vous)Â :

![Default HomePage render](https://user-images.githubusercontent.com/300/76237559-b760ba80-61eb-11ea-9a77-b5006b03031f.png)

Dâ€™accord, Ã§a ne flatte pas encore la rÃ©tine mais câ€™est un dÃ©but! Ouvrez cette page dans votre Ã©diteur, modifiez un peu le texte et sauvegardez. Votre navigateur devrait recharger la page avec vos modifications.

### Routing

Ouvrez `web/src/Routes.js` et observez la route qui vient dâ€™Ãªtre crÃ©Ã©eÂ :

```html
<Route path="/" page={HomePage} name="home" />
```

Essayez de modifier cette route de la faÃ§on suivante:

```html
<Route path="/hello" page={HomePage} name="home" />
```

DÃ¨s que vous ajoutez votre premiÃ¨re route, la page d'accueil par dÃ©faut de Redwood disparaÃ®t. DÃ©sormais, lorsqu'aucune route ne peut Ãªtre trouvÃ©e pour l'URL demandÃ©e, Redwood va retourner la page `NotFoundPage`. Modifiez l'URL de votre navigateur pour ouvrir `http://localhost:8910/hello`, vous devriez voir de nouveau le contenu de `HomePage.js`.

Modifiez Ã  nouveau la route pour revenir Ã  son Ã©tat initial `/` avant de continuer. 

## Une Seconde Page et un Lien

Ajoutons donc une page "About" Ã  notre blog de maniÃ¨re Ã  ce que personne n'ignore qui se trouve derriÃ¨re cette application exceptionnelle. Nous allons crÃ©er une nouvelle page en utilisant `redwood`:

    yarn redwood generate page about

Remarquez que nous n'avons pas spÃ©cifiÃ© de chemin cette fois-ci, uniquement le nom de la page. En effet, si vous ne le prÃ©cisez pas, la commande `redwood generate page` crÃ©era une `Route` en lui donnant pour chemin le nom de la page prÃ©fixÃ© par un slash `/`. Dans le cas prÃ©sent, ce sera donc `/about`. 

> **Fragmenter le code pour chaque page**
>
> Au fur et Ã  mesure que vous ajoutez des pages Ã  votre application, vous pouvez lÃ©gitimement vous inquiÃ©ter du fait que le navigateur va devoir tÃ©lÃ©charger un volume initial de donnÃ©es toujours croissant. Soyez rassurÃ©! Redwood va automatiquement fragmenter le code pour chaque page de telle faÃ§on que le chargement soit toujours extrÃªmement vÃ©loce. Vous pouvez donc crÃ©er autant de pages que vous le souhaitez sans vous inquiÃ©ter outre mesure de la taille finale du bundle webpack. Si, dans le cas contraire, vous souhaitez que certaines pages soient spÃ©cifiquement intÃ©grÃ©es dans le bundle principal, il vous est possible de personaliser cette fonctionalitÃ©.

`http://localhost:8910/about` devrait maintenant pointer sur votre nouvelle page. Bien entendu, absolument personne ne va trouver cette page de votre blog en modifiant manuellement l'URL! Ajoutons donc un lien depuis la page d'accueil vers la page About, et vice-versa. Nous commencerons par crÃ©er un simple header et une barre de navigation dans `HomePage.js`:

```javascript{3,7-19}
// web/src/pages/HomePage/HomePage.js

import { Link, routes } from '@redwoodjs/router'

const HomePage = () => {
  return (
    <>
      <header>
        <h1>Redwood Blog</h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.about()}>A Propos</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>Home</main>
    </>
  )
}

export default HomePage
```

Remarquons ici plusieurs points :

- Redwood adore les "[Function Components](https://www.robinwieruch.de/react-function-component)". Nous ferons un usage frÃ©quent des "[React Hooks](https://reactjs.org/docs/hooks-intro.html)" au fil de l'Ã©laboration de notre blog, et ces derniers ne sont actifs que dans les "function components". Vous Ãªtes libres d'utiliser des "class components", mais nous vous recommandons de les Ã©viter sauf cas particulier.
- Les balises Redwood `<Link>`, dans leur usage le plus simple, prennent un seul attribut `to`. Cet attribut `to` appelle une "_named route function_" de faÃ§on Ã  gÃ©nÃ©rer l'URL correcte. Cette fonction possÃ¨de le mÃªme nom que l'attribut `name` prÃ©sent sur la `<Route>`:

  `<Route path="/about" page={AboutPage} name="about" />`

  Si vous n'aimez pas le nom que la commande `redwood generate` utilise pour votre route, vous pouvez parfaitement le changer dans le fichier `Routes.js`! Les routes nommÃ©es sont extrÃªmement utiles car, si vous dÃ©sirez modifiez le chemin associÃ© avec une route, il vous suffit de le modifier dans le fichier `Routes.js` et immÃ©diatement tous les liens qui utilisent cette route pointerons au bon endroit. Vous pouvez Ã©galement passer directement une chaÃ®ne de caractÃ¨res Ã  l'attribut `to`, mais alors vous ne bÃ©nÃ©ficiez plus de ce mÃ©canisme bien utile. 

### Retour Ã  la maison

Une fois sur la page "About", nous n'avons aucun moyen de revenir en arriÃ¨re. Pour y remÃ©dier, ajoutons Ã©galement un lien Ã  cet endroit:

```javascript{3,7-25}
// web/src/pages/AboutPage/AboutPage.js

import { Link, routes } from '@redwoodjs/router'

const AboutPage = () => {
  return (
    <>
      <header>
        <h1>Redwood Blog</h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>
        <p>
          Ce site est crÃ©Ã© avec pour seule intention de dÃ©montrer la puissance crÃ©ative de Redwood! Oui, c'est trÃ¨s 
          impressionant :D
        </p>
        <Link to={routes.home()}>Retour Ã  la page d'accueil</Link>
      </main>
    </>
  )
}

export default AboutPage
```

Bien! Affichons cette page dans le navigateur and vÃ©rifions que nous pouvons aller et venir entre les diffÃ©rentes pages.

En tant que dÃ©veloppeur de classe cosmique, vous avez probablement repÃ©rÃ© ce copier-coller un peu lourd du `<header>`. Nous aussi. C'est la raison pour laquelle Redwood dispose d'un petite chose bien pratique appelÃ© "_Layout_"."

## Layouts

Une faÃ§on de rÃ©soudre la duplication du `<header>` aurait pu Ãªtre de crÃ©er un composant `<Header>` et l'inclure Ã  la fois dans `HomePage` et `AboutPage`. C'est valide! Mais il y a beaucoup mieux... Dans l'idÃ©al, votre code ne devrait comporter qu'une seule et unique balise `<header>`.

Lorsque vous regardez Ã  ces deux pages, quelle est leur raison d'Ãªtre principale? Toutes deux ont un peu de contenu Ã  afficher. Toutes deux ne devraient pas avoir Ã  connaÃ®tre ce qui vient avant ce contenu (comme un `<header>`), ou aprÃ¨s ce mÃªme contenu (comme un `<footer>`). C'est exactement ce que font les "Layouts": ils entourent une page dans un composant qui va ensuite afficher Ã  l'intÃ©rieur le contenu de la page:

<img src="https://user-images.githubusercontent.com/300/70486228-dc874500-1aa5-11ea-81d2-eab69eb96ec0.png" alt="Diagramme de structure des Layouts" width="300">

Utilisons Redwood pour gÃ©nÃ©rer un layout contenant ce `<header>` :

    yarn redwood g layout blog

> **raccourci `generate`**
>
> DÃ©sormais nous utiliserons le raccourci `g` Ã  la place de `generate`

Ce faisant, nous avons crÃ©Ã© le fichier `web/src/layouts/BlogLayout/BlogLayout.js` et un son fichier de test associÃ©. Nous appellerons ce dernier le "blog" layout car nous aurons certainement d'autres layout plus tard (un layout "admin" par exemple).

Supprimez ce `<header>` de `HomePage` et `AboutPage` et copier son contenu Ã  l'intÃ©rieur du layout. Supprimons Ã©galement le doublon de la balise `<main>` par la mÃªme occasion.

```javascript{3,7-19}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'

const BlogLayout = ({ children }) => {
  return (
    <>
      <header>
        <h1>Redwood Blog</h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>{children}</main>
    </>
  )
}

export default BlogLayout
```

`children` est l'endroit oÃ¹ la magie opÃ¨re! Toute page passÃ©e en argument Ã  un layout s'affiche lÃ . Pour en revenir Ã  `HomePage` et `AboutPage`, en les entourant simplement au sein du `<BlogLayout>`, nos deux pages ne font dÃ©sormais que ce qu'elles sont supposÃ©es faire: afficher leur contenu. Nous pouvons maintenant supprimer les imports de `Link`et `Route` puisqu'ils figurent Ã©galement dans le Layout.

```javascript{3,6}
// web/src/pages/HomePage/HomePage.js

import BlogLayout from 'src/layouts/BlogLayout'

const HomePage = () => {
  return <BlogLayout>Home</BlogLayout>
}

export default HomePage
```

```javascript{4,8-14}
// web/src/pages/AboutPage/AboutPage.js

import { Link, routes } from '@redwoodjs/router'
import BlogLayout from 'src/layouts/BlogLayout'

const AboutPage = () => {
  return (
    <BlogLayout>
        <p>
          Ce site est crÃ©Ã© avec pour seule intention de dÃ©montrer la puissance crÃ©ative de Redwood! Oui, c'est trÃ¨s 
          impressionant :D
        </p>
      <Link to={routes.home()}>Return home</Link>
    </BlogLayout>
  )
}

export default AboutPage
```

> **L'alias `src`**
>
> Remarquez que l'import utilise `src/layouts/BlogLayout` et non `../src/layouts/BlogLayout` ou `./src/layouts/BlogLayout`. Pouvoir se contenter d'ajouter uniquement `src` est un petit apport bien pratique de Redwood: `src` est un alias pour le chemin du rÃ©pertoire `src` du workspace courant. En d'autres termes, lorsque vous travaillez dans `web`, `src` pointe vers `web/src`. Et lorsque vous travaillez dans `api` il pointe vers `api/src`. 

Revenez donc dans votre navigateur, et vous devriez alors voir...... rien de nouveau. Et c'est trÃ¨s bien! Votre layout fonctionne parfaitement.

> **Pourquoi certaines choses sont nommÃ©es d'une certaine faÃ§on?**
>
> Il est possible que vous ayez remarquÃ© quelques rÃ©petitions dans le nom des fichiers utilisÃ©s par Redwood. Ainsi les pages se trouvent dans un rÃ©pertoire appelÃ© `/pages`, et contiennent de nouveau `Page` dans leur nom. Idem pour les Layouts. Pourquoi de choix?
>
> Lorsque vous avez des dizaines de fichiers ouverts dans votre Ã©diteur de code, il est facile de se perdre. C'est d'autant plus le cas lorsque vous avez des fichiers aux noms similaires dans des rÃ©pertoires diffÃ©rents. A l'usage, il nous est apparut que cette petite rÃ©petition dans les noms Ã©tait au final bien pratique lorsqu'il s'agit de repÃ©rer un fichier prÃ©cis parmi tous les onglets ouverts..
>
> Le plugin [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) peut Ã©galement vous aider Ã  distinguer les fichiers entre eux.
>
> <img src="https://user-images.githubusercontent.com/300/73025189-f970a100-3de3-11ea-9285-15c1116eb59a.png" width="400">

### Retour Ã  la Maison, encore une fois

Ajoutons encore un autre `<Link>` de faÃ§on Ã  ce que le titre et le logo pointent vers la page d'accueil:

```javascript{9-11}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'

const BlogLayout = ({ children }) => {
  return (
    <>
      <header>
        <h1>
          <Link to={routes.home()}>Redwood Blog</Link>
        </h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>{children}</main>
    </>
  )
}

export default BlogLayout
```

Enfin nous pouvons Ã©liminer de la page About le lien "Retour Ã  la page d'accueil" devenu superflu (ainsi que les imports `Link` et `routes` associÃ©s).

```javascript
// web/src/pages/AboutPage/AboutPage.js

import BlogLayout from 'src/layouts/BlogLayout'

const AboutPage = () => {
  return (
    <BlogLayout>
      <p>
        Ce site est crÃ©Ã© avec pour seule intention de dÃ©montrer la puissance crÃ©ative de Redwood! Oui, c'est trÃ¨s 
        impressionant :D
      </p>
    </BlogLayout>
  )
}

export default AboutPage
```

## Devenir Dynamique

La seconde partie du didacticiel est disponible en video ici:

<div class="relative pb-9/16">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/SP5vbsWf5Yg?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

Ces deux pages sont plutÃ´t sympas, mais un blog sans article c'est tout de mÃªme un peu lÃ©ger! Travaillons sur ce point Ã  prÃ©sent.

Pour les besoins de ce didacticiel, nous allons rÃ©cupÃ©rer nos articles depuis la base de donnÃ©es. Puisque les bases de donnÃ©es relationelles sont encore aujourd'hui au coeur de beaucoup d'applications complexes (ou moins complexes d'ailleurs), nous avons fait en sorte de rÃ©server un traitement de premiÃ¨re classe aux accÃ¨s SQL. Dans une application Redwood, tout part du schÃ©ma. 

### CrÃ©er le schÃ©ma de la base de donnÃ©es

Nous devons identifier quelles donnÃ©es seront nÃ©cessaires pour un article. Plus tard nous ajouterons d'autres Ã©lÃ©ments, mais pour commencer nous avons besoin de ceci:

- `Ã¬d` l'identifiant unique pour un article (chaque table de notre base de donnÃ©es aura Ã©galement un identifiant tel que celui-ci)
- `title` le titre de l'article
- `body` le contenu de l'article
- `createdAt` un 'timestamp' correspondant au moment oÃ¹ l'article est enregistrÃ© dans la base de donnÃ©es

Nous utilisons [Prisma Client JS](https://github.com/prisma/prisma-client-js) pour parler vac la base de donnÃ©es. Prisma possÃ¨de aun autre librairie, appellÃ©e [Migrate](https://github.com/prisma/migrate), qui nous permet de mettre Ã  jour le schÃ©ma de la base de donnÃ©es en capturant chaque changement successif. Chacun de ces changement est appelÃ© _migration_, et cette librairie Migrate en crÃ©Ã© un nouveau Ã  chaque modification du schÃ©ma.  

Tout d'abord, dÃ©finissons la structure d'un article de notre blog dans la base de donnÃ©es. Ouvrez `api/prisma/schema.prisma` et ajoutez la dÃ©finition de la table `Post` (supprimez au passage tous les modÃ¨les prÃ©sents par dÃ©faut dans ce fichier). Une fois terminÃ©, le fichier se prÃ©sente ainsi: 

```plaintext{13-18}
// api/prisma/schema.prisma

datasource DS {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = "native"
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  body      String
  createdAt DateTime @default(now())
}
```

Cette sÃ©rie d'instructions signifie que nous voulons crÃ©er une table `Post` avec les Ã©lÃ©ments suivants:

- Un champ `id` de type `Int`, nous prÃ©cisions Ã  Prisma que cette colonne constitue un identifiant `@id` (de faÃ§on Ã  pouvoir crÃ©er des relations avec d'autres tables) et que la valeur par `@default` correspond Ã  la fonction Prisma `autoincrement()` impliquant que la base de donnÃ©es insÃ¨rera une nouvelle valeur automatiquement lorsqu'un enregistrement est crÃ©Ã©.
- Un champ `title` de type `String`
- Un champ `body` Ã©galement de type `String`
- Un champ `createdAt` de type `DateTime` avec une valeur par `@default` Ã©gale Ã  `now()` pour chaque nouvel enregistrement (ainsi nous n'avons pas Ã  nous en charger dans l'application, la base de donnÃ©es le fera pour nous)

> **Identifiant de type Integer vs. identifiant de type String**
>
> Pour le didacticiel, nous resterons simple et utiliserons un identifiant de type Integer. Ceci Ã©tant, une application plus Ã©voluÃ©e pourra utiliser un identifiant de type CUID ou UUID. Tous deux sont pris en charge par Prisma. Dans ce cas, vous utiliseriez un champ de type `String` au lieu de `Int`, et `cuid()` ou `uuid()` au lieu de `autoincrement()`:
>
> `id String @id @default(cuid())`
>
> Notez que l'utilisation d'un identifiant de type Integer permet d'obtenir des url plus simples comme https://redwoodblog.com/posts/123 instead of https://redwoodblog.com/posts/eebb026c-b661-42fe-93bf-f1a373421a13. 
>
> Allez voir la [documentation officielle de Prisma](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/data-model#defining-an-id-field) pour plus de dÃ©tails sur les champs identifiants.

### Migrations

Bon, la crÃ©ation du schÃ©ma : c'est fait! Maintenant ce que nous vonlons c'est capturer son Ã©tat pour en faire une _migration_:

    yarn redwood db save create posts

Ce faisant, vous venez de nommer votre premiÃ¨re migration "create posts". Redwood ne tient pas compte de ce nom, mais il est recommandÃ© de choisir un nom significatif pour les autres dÃ©veloppeurs de votre Ã©quipe.

Une fois la commande exÃ©cutÃ©e, vous pourrez constater la crÃ©ation d'un nouveau sous-rÃ©pertoire dans `api/prisma/migrations` avec un _timestamp_ et le nom que vous avez donnÃ© votre migration. Ce sous-rÃ©pertoire contient quelques fichiers: une capture du schÃ©ma de la base dans `schema.prisma`, ainsi que la suite de directives que Prima utilise pour effectuer les modifications dans `steps.json`).

Nous allons maintenant appliquer cette migration avec cette commande:

    yarn rw db up

> **RaccourÃ§i `redwood`**
>
> DÃ©sormais, nous utiliserons dans nos commandes la forme courte `rw` Ã  la place de `redwood`.

L'exÃ©cution de cette commande permet Ã  Prisma d'appliquer les changements sur la base de donnÃ©es, en l'espÃ¨ce la crÃ©ation d'une nouvelle table `Post` avec les champs dÃ©finis plus haut.

### CrÃ©er une Interface d'Ã‰dition d'un Article

Nous n'avons pas encore dÃ©cidÃ© du look de notre site, mais ne serait-il pas extra si nous pouvions commencer Ã  manipuler nos articles de blog, commencer Ã  crÃ©er quelques pages rapidement le temps que l'Ã©quipe chargÃ©e du design rende sa copie? Heureusement pour nous, "Incroyable" est le petit nom de Redwood :)

GÃ©nÃ©rons tout ce sont nous avons besoin pour rÃ©aliser un CRUD (Create, Retrieve, Update, Delete) (CrÃ©er, RÃ©cupÃ©rer, Mettre Ã  jour, Supprimer) sur nos articles. Redwood a justement un generateur spÃ©cialement fait pour Ã§a :

    yarn rw g scaffold post

Ouvrons la page `http://localhost:8910/posts` et constatons le rÃ©sultat:

<img src="https://user-images.githubusercontent.com/300/73027952-53c03080-3de9-11ea-8f5b-d62a3676bbef.png" />

Humm.. Ã§a n'est pas beaucoup plus que ce que nous avions obtenu losque nous avions crÃ©Ã© notre premiÃ¨re page. Que se passe-t-il lorsque nous cliquons sur le bouton "New Post" (Nouvel Article) ?

<img src="https://user-images.githubusercontent.com/300/73028004-72262c00-3de9-11ea-8924-66d1cc1fceb6.png" />

Ah, maintenant on commence Ã  parler sÃ©rieusement! Remplissez donc les champs _title_ (titre) et _body_ (contenu), puis cliquez sur "Save" pour enregistrer.

<img src="https://user-images.githubusercontent.com/300/73028757-08a71d00-3deb-11ea-8813-046c8479b439.png" />

Venons-nous bien de crÃ©er un nouvel article? Exactement! Essayez-donc d'en crÃ©er d'autres.

<img src="https://user-images.githubusercontent.com/300/73028839-312f1700-3deb-11ea-8e83-0012a3cf689d.png" />

Et maintenant, que se passe-t-il lorsqu'on clique sur "Edit" (Ã©diter) pour l'un de ces articles?

<img src="https://user-images.githubusercontent.com/300/73031307-9802ff00-3df0-11ea-9dc1-ea9af8f21890.png" />

D'accord, et en cliquant sur le bouton "Delete" (supprimer)?

<img src="https://user-images.githubusercontent.com/300/73031339-aea95600-3df0-11ea-9d58-475d9ef43988.png" />

Oui c'est bien Ã§a, en une seule commande, Redwood Ã  crÃ©Ã© l'ensemble des pages, composants et services nÃ©cessaires aux opÃ©rations usuelles de manipulation des articles. Pas mÃªme besoin d'ouvrir le gestionnaire de base de donnÃ©es. Redwood appelle ceci des _scaffolds_. Pas mal, non?

Voici dans le dÃ©tail ce qui arrive lorsqu'on execute la commande `yarn rw g scaffold post` : 

- Ajout d'un fichier _SDL_ pour dÃ©finir quelques requÃªtes et mutations GraphQL dans `api/src/graphql/posts.sdl.js` 
- Ajout d'un fichier _service_ `api/src/services/posts/posts.js` qui permet au client Javascript Prisma de manipuler la base de donnÃ©es
- Ajout de quelques _pages_ dans `web/src/pages`:  
  - `EditPostPage` pour Ã©diter un article
  - `NewPostPage` pour crÃ©er un nouvel article
  - `PostPage` pour montrer les dÃ©tails d'un article
  - `PostsPage` pour lister tous les articles
- Ajout de _routes_ pour ces nouvelles pages dans `web/src/Routes.js`
- Ajout de trois _cells_ dans `web/src/components`:
  - `EditPostCell` cellule permettant de rÃ©cupÃ©rer un article pour l'Ã©diter
  - `PostCell` cellule permettant de rÃ©cupÃ©rer un article pour l'afficher
  - `PostsCell` cellule permettant de rÃ©cupÃ©rer tous les articles
- Ajout de quatre _composants_ Ã©galement dans `web/src/components`:
  - `NewPost` affiche le formulaire permettant la crÃ©ation d'un nouvel article
  - `Post` affiche un article en particulier
  - `PostForm` le formulaire utilisÃ© Ã  la fois par les composants de crÃ©ation et d'Ã©dition d'un aricle 
  - `Posts` affiche la table avec l'ensemble des articles

> **GÃ©nÃ©rateurs et conventions de nommage**
>
> Vous remarquerez que certains fichiers gÃ©nÃ©rÃ©s ont un nom au pluriel, et d'autres au singulier. Cette convention est empruntÃ©e au framework Ruby on Rails. Lorsque vous avez Ã  traiter d'un multiple de quelque chose (comme par exemple une liste d'articles), on utilisera le pluriel. Dans le cas contraire (par exemple la crÃ©ation d'un nouvel article), on utilisera le singulier. C'est aussi plus naturel lorsque l'on parle: "montre moi une liste d'articles" vs. "je vais crÃ©er un nouvel article".
>
> Pour ce qui concerne les gÃ©nÃ©rateurs:
>
> - Les fichiers de Services sont toujours au pluriel.
> - Les mÃ©thodes dans les Services sont au singulier ou au pluriel selon qu'ils retournent plusieurs articles ou un seul article (`posts` vs. `createPost`).
> - les fichiers SDL sont toujours au pluriel.
> - Les pages gÃ©nÃ©rÃ©es par une commande de scaffold sont au pluriel ou au singulier selon que la page manipule plusieurs ou un seul article. Notez que lorsque vous utilisez vous-mÃªme un commande `page` en dehors d'un scaffold, le nom utilisÃ© sera simplement celui que vous donnerez.
> - Les Layouts utilisent le nom que vous leur donnez
> - Les composants et les cellules sont au pluriel ou au singulier selon le contexte lorsqu'ils sont gÃ©nÃ©rÃ©s par scaffolding. Dans le cas contraire, ils utilisent simplement le nom que vous leur donnez.
>
> Remarquez Ã©galement que seul le nom de la table en base de donnÃ©es et au singulier ou au pluriel, et pas le mot complet. Ainsi on a `PostsCell`, et non `PostCells`. 
>
> Vous n'avez pas Ã  suivre cette convention de faÃ§on obligatoire lorsque vous crÃ©ez vos propres composants, pages, etc... Ceci Ã©tant nous vous le recommandons chaudement. Au bout du compte, la communautÃ© Ruby on Rails a fini par s'attacher Ã  cette convention, et ce mÃªme si au dÃ©part de nombreuses personnes s'y Ã©taient opposÃ©es. "[Give it five minutes](https://signalvnoise.com/posts/3124-give-it-five-minutes)" comme disent les anglo-saxons.

### CrÃ©er la page d'accueil

Nous pouvons commencer Ã  remplacer ces pages les unes aprÃ¨s les autres au fur et Ã  mesure que l'Ã©quipe chargÃ©e du design nous donne des Ã©lÃ©ments, ou bien nous pouvons simplement les dÃ©placer dnas la partie "administration" de notre site, et commencer Ã  crÃ©er nos propres pages. Ceci Ã©tant, la partie publique du site ne va certainement pas autoriser les utilisateurs Ã  crÃ©er, Ã©diter ou supprimer les articles. Que peuvent donc faire les utilisateurs?

1. Voir la liste des articles (sans liens pour Ã©diter ou supprimer)
2. Voir le dÃ©tail d'un article

Puisque nous voudront probablement conserver un moyen de crÃ©er et Ã©diter des articles plus tard, conservons les pages gÃ©nÃ©rÃ©es par scaffolding et crÃ©ons-en de nouvelles pour ces deux cas de figure.

Nous avons dÃ©jÃ  la `HomePage`, pas besoin de crÃ©er celle-ci donc. Nous souhaitons afficher une liste d'articles Ã  l'utilisateur donc nous allons devoir ajouter Ã§a. Nous avons besoin de rÃ©cupÃ©rer le contenu depuis la base de donnÃ©es, et nous ne voulons pas que l'utilisateur soit face Ã  une page blanche le temps du chargement (conditions rÃ©seau dÃ©gradÃ©es, serveur gÃ©ographiquement distant, etc...), donc nous voudrons montrer une sorte de message de chargement et/ou une animation. D'autre part, si une erreur se produit, nous devrons faire en sorte de la prendre en charge. Enfin, nous devrons Ã©galement prendre en compte le cas oÃ¹ le blog ne contient encore aucun article. 

Wow... notre premiÃ¨re page et il semble que nous ayons dÃ©jÃ  Ã  nous inquiÃ©ter de tant de choses... mais est-ce vÃ©ritablement le cas ? 

## Cells

Ce que nous cherchons Ã  faire ici constituent en rÃ©alitÃ© des objectifs partagÃ©s par la plupart des applications web. Nous voulions voir s'il Ã©tait possible de faciliter la vie aux dÃ©veloppeurs. Nous pensons Ãªtre arrivÃ© Ã  rÃ©aliser quelque chose d'utile. Nous appelons Ã§a les _Cells_ (ou _cellules_ en franÃ§ais). Les Cells proposent une approche simple et dÃ©clarative pour rÃ©cupÃ©rer des donnÃ©es au sein de vos composants. (Vous pouvez lire la documentation complÃ¨te Ã  propos des Cells. You can read the full documentation about Cells [ici](https://redwoodjs.com/docs/cells).

Lorsque vous crÃ©ez une nouvelle Cell, vous exportez quelques constantes, toujours nommÃ©es de faÃ§on identique, et Redwood s'appuie dessus pour mettre en place la mÃ©canique. Une Cell ressemble typiquement Ã  ceci:

```javascript
export const QUERY = gql`
  query {
    posts {
      id
      title
      body
      createdAt
    }
  }
`

export const Loading = () => <div>Chargement...</div>

export const Empty = () => <div>Aucun article disponible!</div>

export const Failure = ({ error }) => (
  <div>Erreur lors du chargement des articles: {error.message}</div>
)

export const Success = ({ posts }) => {
  return posts.map((post) => (
    <article>
      <h2>{post.title}</h2>
      <div>{post.body}</div>
    </article>
  ))
}
```

Lorsque React affiche ce composant, Redwood va:

- ExÃ©cuter la requÃªte `QUERY` et afficher le composant `Loading` jusqu'Ã  ce qu'une rÃ©ponse soit reÃ§ue
- Lorsque la requÃªte retourne une rÃ©ponse, il va afficher un des trois Ã©tats suivants:
  - S'il y a eu une erreur, le composant `Failure`
  - Si aucune donnÃ©e n'est retournÃ©e (c'est Ã  dire `null` ou un tableau vide), le composant `Empty`
  - Dans le cas contraire (ni erreur, ni vide), le composant `Success`

Il existe Ã©galement quelques outils supplÃ©mentaire pour gÃ©nÃ©rer le cycle de vie du composant comme `beforeQuery` (pour manipuler les propriÃ©tÃ©s passÃ©es Ã  `QUERY`) et `afterQuery` (pour manipuler les donnÃ©es retournÃ©es par GraphQL avant qu'elles ne soient transmises au composant `Success`)

Le minimum dont vous avez besoin pour une Cell sont les exports `QUERY` et `Success`. Si vous n'exportez pas `Empty`, `Success` recevra les donnÃ©es vides. Si vous n'exportez pas `Failure`, les Ã©ventuelles erreurs seront envoyÃ©es Ã  la console.

Pour dÃ©terminer dans quels cas utiliser les Cells, gardez en tÃªte qu'elles sont utiles lorsque vos composants ont besoin de rÃ©cupÃ©rer des donnÃ©es depuis la base, ou depuis tout autre service qui pourrait avoir un dÃ©lai de rÃ©ponse. Laissez Redwood se charger de jongler avec les Ã©tats, de maniÃ¨re Ã  pouvoir porter votre attention sur le comportement attendu de vos composants correctement affichÃ©s avec leur donnÃ©es.

### Notre PremiÃ¨re Cell

La page d'accueil affichant une liste d'articles est un candidat parfait pour rÃ©aliser notre premiÃ¨re cellule. Naturellement, nous avons prÃ©vu un gÃ©nÃ©rateur pour Ã§a:

    yarn rw g cell BlogPosts

L'exÃ©cution de cette commande provoque la crÃ©ation d'un nouveau fichier `/web/src/components/BlogPostsCell/BlogPostsCell.js` (et son fichier de test associÃ©) avec un peu de code par dÃ©faut pour vous faciliter la tÃ¢che:

```javascript
// web/src/components/BlogPostsCell/BlogPostsCell.js

export const QUERY = gql`
  query BlogPostsQuery {
    blogPosts {
      id
    }
  }
`

export const Loading = () => <div>Loading...</div>

export const Empty = () => <div>Empty</div>

export const Failure = ({ error }) => <div>Error: {error.message}</div>

export const Success = ({ blogPosts }) => {
  return JSON.stringify(blogPosts)
}
```
> Lorsque vous utilisez le gÃ©nÃ©rateur, vous pouvez employer le type de casse qui vous plaÃ®t. Redwood fera en sorte de s'adapter pour crÃ©er une cellule avec un nom de fichier correct. Ainsi toutes les commandes ci-dessous aboutissent Ã  crÃ©er un fichier avec le mÃªme nom:
>
>     yarn rw g cell blog_posts
>     yarn rw g cell blog-posts
>     yarn rw g cell blogPosts
>     yarn rw g cell BlogPosts
>
> Vous devez juste pensez Ã  indiquer d'une faÃ§on ou d'une autre que vous utilisez plusieurs mots. Appeler `yarn redwood g cell blogposts` sans utiliser aucune casse pour sÃ©parer "blog" et "posts" va gÃ©nÃ©rer un fichier `web/src/components/BlogpostsCell/BlogpostsCell.js`.  

Pour vous aider Ã  Ãªtre efficace, le gÃ©nÃ©rateur suppose que vous utiliserez une requÃªte racine GraphQL nommÃ©es de la mÃªme faÃ§on que votre Cell et Ã©crit pour vous une requÃªte minimale pour rÃ©cupÃ©rer des donnÃ©es depuis la base. Dans le cas prÃ©sent, la requÃªte a donc Ã©tÃ© nommÃ©e `blogPosts`. Cependant, ce nom de requÃªte n'est pas valide par rapport Ã  ce qui a dÃ©jÃ  Ã©tÃ© crÃ©Ã© dans nos fichiers SDL et Service. Nous devons donc renommer `blogPosts` en `posts` Ã  la fois dans le nom de la requÃªte GraphQL et dans la propriÃ©tÃ© passÃ©e Ã  `Success`: 

```javascript{5,17,18}
// web/src/components/BlogPostsCell/BlogPostsCell.js

export const QUERY = gql`
  query BlogPostsQuery {
    posts {
      id
    }
  }
`

export const Loading = () => <div>Loading...</div>

export const Empty = () => <div>Empty</div>

export const Failure = ({ error }) => <div>Error: {error.message}</div>

export const Success = ({ posts }) => {
  return JSON.stringify(posts)
}
```

InsÃ©rons cette Cell dans notre `HomePage` et voyons ce qui se passe:

```javascript{4,9}
// web/src/pages/HomePage/HomePage.js

import BlogLayout from 'src/layouts/BlogLayout'
import BlogPostsCell from 'src/components/BlogPostsCell'

const HomePage = () => {
  return (
    <BlogLayout>
      <BlogPostsCell />
    </BlogLayout>
  )
}

export default HomePage
```

Le navigateur devrait en principe montrer un tableau avec un peu de contenu (en supposant que vous ayez crÃ©Ã© un article Ã  l'Ã©tape du [scaffolding](/tutorial/getting-dynamic#creating-a-post-editor) un peu plus tÃ´t). Impeccable!

<img src="https://user-images.githubusercontent.com/300/73210519-5380a780-40ff-11ea-8639-968507a79b1f.png" />

> **Dans le composant `Success`, d'oÃ¹ vient donc `posts`?**
>
> Remarquez que dans le composant `QUERY`, nous avons nommÃ©e notre requÃªte `posts`. Quelque soit le nom de la requÃªte, ce sera le nom de la propriÃ©tÃ© qui sera transmise au composant `Success` et qui  contiendra vos donnÃ©es. Vous pouvez toutefois crÃ©er un alias de la faÃ§on suivante:  
>
> ```javascript
> export const QUERY = gql`
>   query BlogPostsQuery {
>     postIds: posts {
>       id
>     }
>   }
> `
> ```
>
> De cette maniÃ¨re la propriÃ©tÃ© `postIds` sera transmise Ã  `Success` au lieu de `posts`

En plus de l'identifiant `id` qui a Ã©tÃ© ajoutÃ© dans `QUERY` par le gÃ©nÃ©rateur, rÃ©cupÃ©rons Ã©galement le titre, le contenu et la date de crÃ©ation de l'article:

```javascript{7-9}
// web/src/components/BlogPostsCell/BlogPostsCell.js

export const QUERY = gql`
  query BlogPostsQuery {
    posts {
      id
      title
      body
      createdAt
    }
  }
`
```

La page devrait dÃ©sormais afficher un dump de l'ensemble des donnÃ©es pour tous les articles enregistrÃ©s:

<img src="https://user-images.githubusercontent.com/300/73210715-abb7a980-40ff-11ea-82d6-61e6bdcd5739.png" />

`Success` est ni plus ni moins qu'un bon vieux composant React, vous pouvez donc le modifier simplement pour afficher chaque article dans un format un peu plus sympa et lisible:

```javascript{4-12}
// web/src/components/BlogPostsCell/BlogPostsCell.js

export const Success = ({ posts }) => {
  return posts.map((post) => (
    <article key={post.id}>
      <header>
        <h2>{post.title}</h2>
      </header>
      <p>{post.body}</p>
      <div>CrÃ©Ã© le: {post.createdAt}</div>
    </article>
  ))
}
```

Et ce faisant, nous avons maintenant notre blog! Ok, Ã  ce stade c'est encore le plus basique et hideux blog jamais vu sur Internet.. mais c'est dÃ©jÃ  quelque chose! (Pas d'inquiÃ©tude, nous avons encore un tas de fonctionnalitÃ©s Ã  ajouter)

<img src="https://user-images.githubusercontent.com/300/73210997-3dbfb200-4100-11ea-847a-602cbf59cb2a.png" />

### RÃ©sumÃ©

Pour rÃ©sumer, qu'avons nous rÃ©alisÃ© jusqu'ici ?

1. GÃ©nÃ©ration de la page d'accueil
2. GÃ©nÃ©ration du Layout pour notre blog
3. DÃ©finition du schÃ©ma de la base de donnÃ©es
4. Application d'une migrations pour mettre Ã  jour la base de donnÃ©es et crÃ©er une table
5. RÃ©alisation d'un Scaffold pour crÃ©er une interface CRUD sur la table
6. CrÃ©ation d'une Cell pour charger les donner et gÃ©rer les Ã©tats "loading", "empty", "failure" et enfin "success". 
7. Ajout de la Cell Ã  notre page d'accueil

En rÃ©alitÃ©, cette diffÃ©rentes Ã©tapes sont ni plus ni moins ce qui deviendra votre faÃ§on habituelle d'ajouter de nouvelles fonctionnalitÃ©s dans une application Redwood.

Jusqu'ici, hormis un peu de code HTML, nous n'avons pas Ã©crit grand chose Ã  la main. En particulier, nous n'avons pratiquement pas eu Ã  Ã©crire de code pour rÃ©cupÃ©rer les donnÃ©es depuis la base. Le dÃ©veloppement web s'en trouve facilitÃ© et devient mÃªme agrÃ©able, qu'en pensez-vous?

## QuÃªte secondaire: Fonctionnement de Redwood avec les DonnÃ©es

Redwood apprÃ©cie GraphQL. Nous pensons qu'il s'agit de l'API pour l'avenir. Notre implÃ©mentation de GraphQL is construite avec [Apollo](https://www.apollographql.com/). Voici comment une requÃªte GraphQL classique fonctionne dans votre application: 

![Redwood Data Flow](https://user-images.githubusercontent.com/300/75402679-50bdd180-58ba-11ea-92c9-bb5a5f4da659.png)

La partie frontend de l'application s'appuie sur [Apollo Client](https://www.apollographql.com/docs/react/) pour crÃ©er une requÃªte GraphQL. Celle-ci est ensuite envoyÃ©e Ã  [Apollo Server](https://www.apollographql.com/docs/apollo-server/) qui s'exÃ©cute dans une fonction lambda AWS serverless.  

Les fichiers `*.sdl.js` qui se trouvent dans le rÃ©pertoire `api/src/graphql` dÃ©finissent les types GraphQL [Object](https://www.apollographql.com/docs/tutorial/schema/#object-types), [Query](https://www.apollographql.com/docs/tutorial/schema/#the-query-type) et [Mutation](https://www.apollographql.com/docs/tutorial/schema/#the-mutation-type) et donc l'interface de votre API.

En principe, vous devriez Ã©crire une "[resolver map](https://www.apollographql.com/docs/tutorial/resolvers/#what-is-a-resolver)" qui contiendrait l'ensemble de vos "resolvers" de faÃ§on Ã  ce qu'Apollo sache comment les brancher Ã  vos fichiers SDL. Cependant, inscrire votre logique mÃ©tier directement dans votre "resolver map" aurait pour consÃ©quence la crÃ©ation d'un Ã©norme fichier ne favorisant pas la rÃ©utilisation. Vous pourriez Ã©galement extraire toute cette logique dans une librairie de fonctions que vous importeriez et appelleriez depuis votre "resolver map", en ayant toutefois Ã  vous rappeller de passer tous les arguments nÃ©cessaires. Humm.. c'est beaucoup d'efforts pour au final une masse de code de toute faÃ§on peu rÃ©utilisable.

Redwood s'y prend autrement! Voos rappellez-vous le rÃ©pertoire `api/src/services`? Redwood va automatiquement importer et brancher vos "resolvers" depuis les **services** vers vos fichiers SDL. Dans le mÃªme temps, Redwood vous permet d'Ã©crire vos "resolvers" de faÃ§on Ã  ce qu'ils soient facilement appellÃ©s comme de simples fonctions depuis d'autres "resolvers" ou d'autres services. Cela fait pas mal de choses Ã©tonnantes Ã  intÃ©grer, il est temps de passer Ã  un exemple.

Observez donc le morceau de code SDL javascript suivant :

```javascript
// api/src/graphql/posts.sdl.js

export const schema = gql`
  type Post {
    id: Int!
    title: String!
    body: String!
    createdAt: DateTime!
  }

  type Query {
    posts: [Post!]!
    post(id: Int!): Post!
  }

  input CreatePostInput {
    title: String!
    body: String!
  }

  input UpdatePostInput {
    title: String
    body: String
  }

  type Mutation {
    createPost(input: CreatePostInput!): Post!
    updatePost(id: Int!, input: UpdatePostInput!): Post!
    deletePost(id: Int!): Post!
  }
`
```

A partir de ce fichier SDL, Redwood va aller chercher les cinq "resolvers" suivants dans `api/src/services/posts/posts.js` :

- `posts()`
- `post({id})`
- `createPost({input})`
- `updatePost({id, input})`
- `deletePost({id})`

Pour implÃ©menter ces cinq "resolvers", il vous suffit de les exporter depuis vos fichiers services. Vos resolvers vont habituellement rÃ©cupÃ©rer les donnÃ©es depuis une base de donnÃ©es, mais en rÃ©alitÃ© ils peuvent faire ce que vous souhaitez du moment qu'ils retournent le type de donnÃ©es qu'Apollo s'attend Ã  recevoir comme dÃ©fini dans `posts.sdl.js`. 

```javascript
// api/src/services/posts/posts.js
import { db } from 'src/lib/db'

export const posts = () => {
  return db.post.findMany()
}

export const post = ({ id }) => {
  return db.post.findOne({
    where: { id },
  })
}

export const createPost = ({ input }) => {
  return db.post.create({
    data: input,
  })
}

export const updatePost = ({ id, input }) => {
  return db.post.update({
    data: input,
    where: { id },
  })
}

export const deletePost = ({ id }) => {
  return db.post.delete({
    where: { id },
  })
}
```

> Apollo suppose que ces fonctions retournent des "promises", ce que `db` fait parfaitement. `db` est une instance de `PrismaClient`. Apollo attend sagement que ces promises s'achÃ¨vent avant de rÃ©pondre avec le rÃ©sultat de vos requÃªtes. De cette maniÃ¨re, vous n'avez pas Ã  gÃ©rer vous-mÃªme les `async`/`await`, ou autres callbacks. 

Vous Ãªtes parfaitement fondÃ© Ã  vous interroger sur la raison pour laquelle nous appelons ces fichiers des "services". Bien que le blog que nous construisons ensemble ne soit pas assez complexe pour le montrer, les services sont conÃ§us pour Ãªtre une abstraction qui couvre **plus** qu'une simple table de la base de donnÃ©es. Une application plus avancÃ©e pourrait par exemple avoir un service nommÃ© "facturation" qui reposerait Ã  fois sur les tables `transactions` et `souscriptions`. Certaines des fonctionnalitÃ©s de ce service pourraient Ãªtre exposÃ©es via GraphQL, mais pas forcÃ©ment toutes. 

Vous n'avez pas besoin d'exposer chaque fonction de votre service via GraphQL. Si vous ne les dÃ©clarez pas dans dans vos types `Query` ou `Mutation`, ils n'existerons tout simplement pas pour GraphQL. Mais vous pourrez toujours les utiliser vous-mÃªme. Les services ne sont ni plus ni moins que des fonctions javascript que vous pouvez utiliser oÃ¹ bon vous semble :

- Depuis un autre service
- Dans une autre fonction lambda crÃ©Ã©e par vous-mÃªme
- Depuis une autre API, complÃ¨tement sÃ©parÃ©e

En organisant votre application autour de services bien dÃ©finis, et en proposant une API pour chacun de ces services (Ã  la fois pour un usage interne, **et** pour GraphQL), vous contribuerez naturellement Ã  respecter la rÃ¨gle dite de ["separation of concerns"](https://fr.wikipedia.org/wiki/S%C3%A9paration_des_pr%C3%A9occupations) (SoC). Selon toute probabilitÃ©, cela vous permettra de favoriser la maintenance de votre code dans le temps.

Revenons-en Ã  notre flux de donnÃ©es: Apollo a crÃ©Ã© un "resolver" qui, dans notre cas, rÃ©cupÃ¨re les donnÃ©es depuis une base de donnÃ©es. Apollo reconstruit l'objet en ne retournant que les couples clÃ©/valeur demandÃ©s dans la requÃªte GraphQL. Enfin, Apollo emballe la rÃ©ponse au format GraphQL et la retourne au navigateur.

Si vous utilisez une **Cell** Redwood, vos donnÃ©es seront dÃ¨s lors disponible dans votre compsant `Success`, prÃªtes Ã  Ãªtre affichÃ©es comme avec n'importe quel composant React.

## ParamÃ¨tres de Routes

Maintenant que notre page d'accueil liste l'ensemble des articles de notre blog, il est temps de crÃ©er une page prÃ©sentant le dÃ©tail d'un article. CommenÃ§ons par gÃ©nÃ©rer une page et sa route associÃ©e:

    yarn rw g page BlogPost

> Remarquez que nous ne pouvons pas nommer cette page `Post` car une autre page homonyme a dÃ©jÃ  Ã©tÃ© crÃ©e lors de notre prÃ©cÃ©dente dÃ©monstration du scaffolding.

Pour chaque article listÃ© sur la page d'accueil, ajoutons un lien qui pointe vers notre nouvelle page (sans oublier au passage les imports pour `Link` et `routes`):

```javascript{3,12}
// web/src/components/BlogPostsCell/BlogPostsCell.js

import { Link, routes } from '@redwoodjs/router'

// QUERY, Loading, Empty and Failure definitions...

export const Success = ({ posts }) => {
  return posts.map((post) => (
    <article key={post.id}>
      <header>
        <h2>
          <Link to={routes.blogPost()}>{post.title}</Link>
        </h2>
      </header>
      <p>{post.body}</p>
      <div>CrÃ©Ã© le: {post.createdAt}</div>
    </article>
  ))
}
```

Si vous cliquez sur le lien, vous deviez voir s'afficher un peu de texte issu de `BlogPostPage`. Mais ce dont nous avons vraiment besoin, c'est de pouvoir prÃ©ciser _quel_ article nous souhaitons afficher. Ce que nous cherchons a obtenir en dÃ©finitive, c'est une URL du type `/blog-post/1`. Pour cela, nous allons dire au routeur que notre url comporte une partie variable supplÃ©mentaire:

```html
// web/src/Routes.js

<Route path="/blog-post/{id}" page={BlogPostPage} name="blogPost" />
```

Notez l'ajout de `{id}` dans notre route. Redwood nomme ceci un _paramÃ¨tre de route_. Ces paramÃ¨tres de route signifie la chose suivante: "quelque soit la valeur Ã  cette position, elle sera rÃ©fÃ©rencÃ©e par le nom utilisÃ© entre les accolades".

Cool, cool, cool. Maintenant, nous devons donc construire un lien qui possÃ¨de cet identifiant:

```html
// web/src/components/BlogPostsCell/BlogPostsCell.js

<Link to={routes.blogPost({ id: post.id })}>{post.title}</Link>
```

Pour les routes avec paramÃ¨tres, un objet est attendu pour chaque paramÃ¨tre. Si vous cliquez sur le lien d'un article, vous constaterez qu'en effet il pointe dÃ©sormais vers `/blog-post/1` (ou `/blog-post/2`, etc... selon l'article).

### Utilisation des ParamÃ¨tres

OK, donc l'identifiant se trouve bien dans l'URL. Et maintenant que fait-t-on pour afficher le bon article? On dirait bien que nous allons devoir rÃ©cupÃ©rer les donnÃ©es depuis la base. Vous l'aurez compris, c'est le bon moment pour utiliser une Cell:

    yarn rw g cell BlogPost

Nous allons ensuite utiliser cette Cell dans notre page `BlogPostPage` (et pendant que nous y sommes, nous insÃ¨rerons notre page dans notre Layout `BlogLayout`):

```javascript
// web/src/pages/BlogPostPage/BlogPostPage.js

import BlogLayout from 'src/layouts/BlogLayout'
import BlogPostCell from 'src/components/BlogPostCell'

const BlogPostPage = () => {
  return (
    <BlogLayout>
      <BlogPostCell />
    </BlogLayout>
  )
}

export default BlogPostPage
```

Maintenant, Ã  l'intÃ©rieur de notre Cell, nous avons besoin d'accÃ©der Ã  ce paramÃ¨tre de route `{id}` qui contient l'identifiant de notre article en base de donnÃ©es. Pour ce faire, mettons Ã  jour la requÃªte de faÃ§on Ã  ce qu'elle accepte une variable en entrÃ©e. Modifions Ã©galement le nom de la requÃªte `blogPost` en `post`.

```javascript{4,5,7-9,20,21}
// web/src/components/BlogPostCell/BlogPostCell.js

export const QUERY = gql`
  query BlogPostQuery($id: Int!) {
    post(id: $id) {
      id
      title
      body
      createdAt
    }
  }
`

export const Loading = () => <div>Loading...</div>

export const Empty = () => <div>Empty</div>

export const Failure = ({ error }) => <div>Error: {error.message}</div>

export const Success = ({ post }) => {
  return JSON.stringify(post)
}
```

Okay, on approche du but! Ceci Ã©tant, d'oÃ¹ vient donc ce `$id`? Redwood a plus d'un tour dans son sac. Chaque fois que vous ajoutez un paramÃ¨tre de route, ce paramÃ¨tre est automatiquement accessible dans la page qui correspond. Ce qui signifie que vous pouvez modifier la page `BlogPostPage` de la faÃ§on suivante:

```javascript{3,6}
// web/src/pages/BlogPostPage/BlogPostPage.js

const BlogPostPage = ({ id }) => {
  return (
    <BlogLayout>
      <BlogPostCell id={id} />
    </BlogLayout>
  )
}
```

`id` existe dÃ©jÃ  sans effort supplÃ©mentaire puisque nous avons nommÃ© notre paramÃ¨tre de route `{id}`. Merci qui? Merci Redwood! Mais comment se fait-il que cet `id` finisse par devenir un paramÃ¨tre GraphQL `$id`? Redwood s'en charge Ã©galement pour vous! Par dÃ©faut, chaque propriÃ©tÃ© que vous donnez Ã  une Cell devient automatiquement un variable disponible pour une requÃªte GraphQL. Incroyablement simple, et pourtant vrai :)

D'ailleurs on peut le prouver! Essayez maintenant d'aller voir un article and â€” ... uh oh. Hmm:

![image](https://user-images.githubusercontent.com/300/75820346-096b9100-5d51-11ea-8f6e-53fda78d1ed5.png)

> Au passage le code d'erreur que vous voyez s'afficher provient de la section `Failure` de votre Cell!

Si vous examinez la console de votre navigateur, vous constaterez la prÃ©sence d'une erreur GraphQL:

    [GraphQL error]: Message: Variable "$id" got invalid value "1";
      Expected type Int. Int cannot represent non-integer value: "1",
      Location: [object Object], Path: undefined

Il s'avÃ¨re que les paramÃ¨tres de route sont extraits des URL sous la forme de chaÃ®nes de caractÃ¨res, et dans le cas prÃ©sent GraphQL s'attend Ã  recevoir un identifiant sous la forme d'un entier. Nous pourrions simplement utiliser la fonction javascript `parseInt()` afin de convertir notre paramÃ¨tre de route vers un entier avant de le passer Ã  `BlogPostCell`. Mais honnÃªtement, on peut faire bien mieux que Ã§a! 

### ParamÃ¨tres de Route TypÃ©s

Et si vous aviez la possibilitÃ© de demander cette conversion directement dans le chemin de la route? Et bien devinez-quoi, vous pouvez! Redwood appelle Ã§a les **paramÃ¨tres de route typÃ©s** ("route param types" en anglais). Et c'est aussi simple que d'ajouter `:Int` Ã  notre paramÃ¨tre de route:
What if you could request the conversion right in the route's path? Well, guess what: you can! Introducing **route param types**. It's as easy as adding `:Int` to our existing route param:

```html
// web/src/Routes.js

<Route path="/blog-post/{id:Int}" page={BlogPostPage} name="blogPost" />
```

VoilÃ ! Non seulement vous allez convertir sans effort le paramÃ¨tre `id` en un entier avant de la passer Ã  votre Page, mais en bonus vous faÃ®tes en sorte que la route n'applique que si `id` reprÃ©sente effectivement un entier, c'est Ã  dire une suite de chiffres. Dans le cas contraire, le routeur essaiera d'autres routes. S'il ne s'en trouve aucune Ã  s'appliquer, le routeur affichera la page `NotFoundPage`.

> **Que se passe-t-il si je veux passer d'autres propriÃ©tÃ©s Ã  ma Cell dont je n'ai pas besoin dans la requÃªte, mais qui me sont utile dans les composants Success/Loader/etc... ?**
>
> Toutes les propriÃ©tÃ©s que vous donnez Ã  votre Cell seront automatiquement disponibles pour ses composants internes. Seuls ceux qui se se trouvent dans la liste des variables GraphQL seront transmises Ã  la requÃªte. Vous avez ainsi le meilleur des deux mondes! Dans l'affichage de notre article ci-dessus, si vous dÃ©sirez montrer par exemple un nombre au hasard (pour des raisons evidentes liÃ©es Ã  ce didacticiel :D), il vous suffit de passer cette propriÃ©tÃ© Ã  votre Cell:
>
> ```javascript
> <BlogPostCell id={id} rand={Math.random()} />
> ```
> 
> Et ensuite vous la rÃ©cupÃ©rez avec le rÃ©sulat de la requÃªte ans le composant (et mÃªme avec l'identifiant de l'article si vous le souhaitez):
> And get it, along with the query result (and even the original `id` if you want) in the component:
>
> ```javascript
> export const Success = ({ post, id, rand }) => {
>   //...
> }
> ```
>
> Merci Redwood!

### Afficher un Article

Maintenant, affichons un vÃ©ritable article au lieu d'un simple dump du rÃ©sultat de la requÃªte. Il semble que ce soit l'endroit parfait pour utiliser un bon vieux composant puisque nous affichons les articles de faÃ§on identique (pour l'instant) Ã  la fois sur la page d'accueil et sur la page de dÃ©tail.

    yarn rw g component BlogPost

L'exÃ©cution de cette commande crÃ©Ã© le composant `BlogPost` dans le fichier `web/src/components/BlogPost/BlogPost.js`, accompagnÃ© de son fichier de test: 

```javascript
// web/src/components/BlogPost/BlogPost.js

const BlogPost = () => {
  return (
    <div>
      <h2>{'BlogPost'}</h2>
      <p>{'Find me in ./web/src/components/BlogPost/BlogPost.js'}</p>
    </div>
  )
}

export default BlogPost
```

> Vous remarquerez peut-Ãªtre que nous n'avons ici aucun `import` relatif Ã  la librairie `React`. Il s'agit pourtant bien d'un classique composant React. En rÃ©alitÃ©, nous (la "Redwood dev team") sommes un peu fatiguÃ©s d'avoir Ã  importer constamment les mÃªmes fichiers de la mÃªme maniÃ¨re... alors nous avons fait en sorte que Redwood le fasse pour nous, et donc pour vous!

Supprimons la partie de code qui affiche l'article dans `BlogPostCell`, et mettons la plutÃ´t ici. Ce faisant, passons Ã  notre nouveau composant la propriÃ©tÃ© `post`:

```javascript{3,5,7-14}
// web/src/components/BlogPost/BlogPost.js

import { Link, routes } from '@redwoodjs/router'

const BlogPost = ({ post }) => {
  return (
    <article>
      <header>
        <h2>
          <Link to={routes.blogPost({ id: post.id })}>{post.title}</Link>
        </h2>
      </header>
      <div>{post.body}</div>
    </article>
  )
}

export default BlogPost
```

Mettons Ã  jour `BlogPostsCell` et `BlogPostCell` pour utiliser notre composant d'affichage commun:

```javascript{3,8}
// web/src/components/BlogPostsCell/BlogPostsCell.js

import BlogPost from 'src/components/BlogPost'

// Loading, Empty, Failure...

export const Success = ({ posts }) => {
  return posts.map((post) => <BlogPost key={post.id} post={post} />)
}
```

```javascript{3,8}
// web/src/components/BlogPostCell/BlogPostCell.js

import BlogPost from 'src/components/BlogPost'

// Loading, Empty, Failure...

export const Success = ({ post }) => {
  return <BlogPost post={post} />
}
```

Et nous y sommes! Nous devrions maintenant pouvoir aller et venir Ã  notre guise entre la page d'accueil et les articles.

> Si vous apprÃ©ciez ce que vous venez de voir sur le routeur, vous pouvez en apprendre plus dans le [guide](/docs/redwood-router) qui lui est consacrÃ©. 

### RÃ©sumÃ©

Un petit Ã©tat des lieux de ce que nous avons rÃ©alisÃ©:

1. CrÃ©ation d'une nouvelle page pour afficher un article
2. Ajout d'une route prenant en char l'identifiant `id` d'un article sous la forme d'un paramÃ¨tre de route
3. CrÃ©ation d'une Cell permettant de rÃ©cupÃ©rer et afficher un article
4. Constat de la capacitÃ© de Redwood Ã  vous mettre de bonne humeur en vous donnant accÃ¨s Ã  `id` lÃ  oÃ¹ vous en avez besoin tout en le convertissant au format numÃ©rique Ã  la volÃ©e
6. Transformation de l'affichage d'un article en un composant React classique pouvant Ãªtre partagÃ© Ã  plusieurs endroits dans l'interface (en l'espÃ¨ce dans la page d'accueil et la page de dÃ©tail)

## Votre partie prÃ©fÃ©rÃ©e: Les Formulaires

Attendez! Ne partez pas! Vous deviez bien vous douter que Ã§a allait venir, non? Rassurez-vous, pour les formulaires aussi, Redwood a trouvÃ© une faÃ§on de faire qui les rend moins pÃ©nible que d'habitude. En fait, Redwood pourrait mÃªme vous faire _aimer_ les formulaires. Bon, aimer est peut-Ãªtre un peu fort. Disons _apprÃ©cier_ travailler avec les formulaires, ou Ã  tout le moins les _tolÃ©rer_?   

La troisiÃ¨me partie du didacticiel en video commence ici:

<div class="relative pb-9/16">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/eT7iIy0F8Tk?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

Nous avons dÃ©jÃ  un formulaire ou deux dans notre application; vous rappellez-vous notre _scaffolding_ avec les articles? Ils fonctionnaient plus bien, non? Alors, a quel point est-ce difficile de reproduire ces formulaires? (Si vous n'avez pas encore eu la curiositÃ© d'aller voir le code gÃ©nÃ©rÃ©, ce qui va suivre va vous surprendre)

Construisons donc le formulaire le plus Ã©lÃ©mentaire qui soit pour notre blog, et utile de surcroÃ®t, celui qui permettra Ã  vos lecteurs de vous contacter. 

### La Page

    yarn rw g page contact

AprÃ¨s avoir exÃ©cutÃ© cette commande, nous pouvons ajouter un lien vers Contact dans notre Layout:

```javascript{17-19}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'

const BlogLayout = ({ children }) => {
  return (
    <>
      <header>
        <h1>
          <Link to={routes.home()}>Redwood Blog</Link>
        </h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
            <li>
              <Link to={routes.contact()}>Contact</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>{children}</main>
    </>
  )
}

export default BlogLayout
```

And then use the `BlogLayout` in the `ContactPage`:

```javascript{3,6}
// web/src/pages/ContactPage/ContactPage.js

import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  return <BlogLayout></BlogLayout>
}

export default ContactPage
```

VÃ©rifiez que tout fonctionne correctement, puis passons aux rÃ©jouÃ¯ssances.

### PrÃ©sentation des Form Helpers

Les formulaires avec React sont surtout connus pour Ãªtre particuliÃ¨rement agaÃ§ants Ã  construire. Il existes les [Controlled Components](https://reactjs.org/docs/forms.html#controlled-components), les [Uncontrolled Components](https://reactjs.org/docs/uncontrolled-components.html), diverses [librairies tierces](https://jaredpalmer.com/formik/) et enfin pas mal d'astuces diverses pour essayer de les rendre aussi simples qu'ils sont sensÃ©s Ãªtre selon les spÃ©cifications HTML: un champ `<input>` avec un attribut `name` qui sera envoyÃ© quelque part lorsque l'utilisateur clique sur un bouton.  

Nous pensons que Redwood fait quelques pas dans la bonne direction, non seulement en vous libÃ©rant d'avoir Ã  Ã©crire un tans de code relatif aux composants controllÃ©s (controlled components), mais aussi en s'occupant de gÃ©rer automatiquement les validations et Ã©ventuelles erreurs. Regardons ensemble comment tout celÃ  fonctionne.

Avant de commencer, ajoutons quelques classes CSS pour que les formulaires par dÃ©faut s'affichent correctement sans que nous ayons Ã  alourdir notre code avec des attributs `style` un peu partout. Pour le moment nous Ã©crirons ces rÃ¨gles dans le fichier `index.css` situÃ© dans le rÃ©pertoire `web/src`:

```css
/* web/src/index.css */

button, input, label, textarea {
  display: block;
  outline: none;
}

label {
  margin-top: 1rem;
}

.error {
  color: red;
}

input.error, textarea.error {
  border: 1px solid red;
}
```

Pour l'instant nous n'allons pas faire dialoguer notre formulaire de contact avec la base de donnÃ©es, raison pour laquelle nous ne gÃ©nÃ©rons pas une Cell. Nous allons simplement ajouter le formulaire Ã  notre page. Dans Redwood, la crÃ©ation d'un formulaire dÃ©bute par... attention Ã  la surprise...une balise `<Form>`:

```javascript{3,9}
// web/src/pages/ContactPage/ContactPage.js

import { Form } from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  return (
    <BlogLayout>
      <Form></Form>
    </BlogLayout>
  )
}

export default ContactPage
```

Humm, OK... pour le moment rien d'incroyable. Ajoutons un premier champ que l'on puisse au moins afficher quelque chose. Redwood propose une variÃ©tÃ© de type de champs parmi lesquels se trouve `<TextField>`. Ce dernier correspond Ã  un champ text tout ce qu'il y a de plus basique. Il possÃ¨de un attribut `name` de telle faÃ§on que lorsqu'un formulaire contient de multiples champs, il soit possible de savoir lequel contient telle ou telle donnÃ©e.

```javascript{3,10}
// web/src/pages/ContactPage/ContactPage.js

import { Form, TextField } from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  return (
    <BlogLayout>
      <Form>
        <TextField name="input" />
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

<img src="https://user-images.githubusercontent.com/300/80258121-4f4d2300-8637-11ea-83f5-c667e05aaf74.png" />

Enfin quelque chose s'affiche! Pas encore trÃ¨s intÃ©ressant toutefois. Ajoutons un bouton "envoyer".

```javascript{3,11}
// web/src/pages/ContactPage/ContactPage.js

import { Form, TextField, Submit } from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  return (
    <BlogLayout>
      <Form>
        <TextField name="input" />
        <Submit>Save</Submit>
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

<img src="https://user-images.githubusercontent.com/300/80258188-7572c300-8637-11ea-9583-1b7636f93be0.png" />

Nous obtenons ce qu'on peut considÃ©rer comme un vÃ©ritable et authentique formulaire! Essayez de saisir quelque chose et cliquez sur le bouton. Rien n'explose, mais nous n'avons aucune indication que le formulaire Ã  bien Ã©tÃ© envoyÃ© (et vous aurez notÃ© l'apparition d'une erreur dans la console). Voyons Ã  prÃ©sent comment rÃ©cupÃ©rer les donnÃ©es depuis nos champs de formulaire.

### onSubmit

De faÃ§on similaire Ã  un formulaire HTML, une balise `<Form>` possÃ¨de un "_handler_" `onSubmit`. Ce handler sera appelÃ© avec un seul argument: un unique objet contenant l'ensemble des champs du formulaire.

```javascript{4-6,10}
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = () => {
  const onSubmit = (data) => {
    console.log(data)
  }

  return (
    <BlogLayout>
      <Form onSubmit={onSubmit}>
        <TextField name="input" />
        <Submit>Save</Submit>
      </Form>
    </BlogLayout>
  )
}
```

Essayons maintenant de saisir quelques mots puis soumettre ce formulaire:

<img src="https://user-images.githubusercontent.com/300/80258293-c08cd600-8637-11ea-92fb-93d3ca1db3cf.png" />

Extra! Rendons le formulaire un peu plus utile en ajoutant quelques champs supplÃ©mentaires. Nous renommons ainsi notre premier champ en `name` puis ajoutons les champs `email` et `message`:

```javascript{3,15,16}
// web/src/pages/ContactPage/ContactPage.js

import { Form, TextField, TextAreaField, Submit } from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  const onSubmit = (data) => {
    console.log(data)
  }

  return (
    <BlogLayout>
      <Form onSubmit={onSubmit}>
        <TextField name="name" />
        <TextField name="email" />
        <TextAreaField name="message" />
        <Submit>Save</Submit>
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

Remarquez le nouveau composant `<TextAreaField>` qui gÃ©nÃ¨re une balise HTML `<textarea>` contenant quelques spÃ©cificitÃ©s utiles propres Ã  Redwood:

<img src="https://user-images.githubusercontent.com/300/80258346-e4e8b280-8637-11ea-908b-06a1160b932b.png" />

Ajoutons Ã©galement quelques Ã©tiquettes en face des champs:

```javascript{6,9,12}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Form onSubmit={onSubmit}>
      <label htmlFor="name">Name</label>
      <TextField name="name" />

      <label htmlFor="email">Email</label>
      <TextField name="email" />

      <label htmlFor="message">Message</label>
      <TextAreaField name="message" />

      <Submit>Save</Submit>
    </Form>
  </BlogLayout>
)
```

<img src="https://user-images.githubusercontent.com/300/80258431-15c8e780-8638-11ea-8eca-0bd222b51d8a.png" />

Essayez donc de soumettre Ã  nouveau le formulaire, vous devriez obtenir dans la console un message avec le contenu des trois champs.

### Validation

"Humm... cher auteur de ce didacticiel, qui a-t-il d'incroyable jusqu'ici?". C'est sans doute votre Ã©tat d'esprit Ã  ce stade. En effet, il existe dÃ©jÃ  un nombre consÃ©quent de librairies permettant d'obtenir un rÃ©sultat similaire.. Vous avez raison! N'importe qui peut remblir un formulaire _correctement_, mais que se passe-t-il lorsqu'un utilisateur fait une erreur, oubli un champ, voire tente de jouer les hackers? Qui va vous aider Ã  gÃ©rer cette situation? Redwood va le faire. 

Tout d'abord, ce trois champs devraient Ãªtre obligatoirement remplis pour pouvoir soumettre le formulaire. Rendons cette rÃ¨gle obligatoire en utilisant l'attribut HTML standard `required`:

```javascript{7,10,13}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Form onSubmit={onSubmit}>
      <label htmlFor="name">Name</label>
      <TextField name="name" required />

      <label htmlFor="email">Email</label>
      <TextField name="email" required />

      <label htmlFor="message">Message</label>
      <TextAreaField name="message" required />

      <Submit>Save</Submit>
    </Form>
  </BlogLayout>
)
```

<img src="https://user-images.githubusercontent.com/300/80258542-5163b180-8638-11ea-8450-8a727de177ad.png" />

DÃ©sormais, lorsque vous essayez de soumettre le formulaire, un message s'affiche dans votre navigateur. C'est mieux que rien, mais l'apparence de ce message ne peut Ãªtre modifiÃ©e. Peut-on faire mieux?

Oui! RemplaÃ§ons cet attribut `required` par un object que nous passons Ã  un attribut nommÃ© `validation`, spÃ©cifique Ã  Redwood:

```javascript{7,10,13}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Form onSubmit={onSubmit}>
      <label htmlFor="name">Name</label>
      <TextField name="name" validation={{ required: true }} />

      <label htmlFor="email">Email</label>
      <TextField name="email" validation={{ required: true }} />

      <label htmlFor="message">Message</label>
      <TextAreaField name="message" validation={{ required: true }} />

      <Submit>Save</Submit>
    </Form>
  </BlogLayout>
)
```

Maintenant lorsqu'un champ reste vide, le formulaire n'est pas envoyÃ© et le champ en question prend le focus de telle maniÃ¨re que l'utilisateur puisse saisir une valeur. Pas encore stupÃ©fiant, mais c'est une premiÃ¨re Ã©tape. Redwood a d'autres fonctions sympatiques pour les formulaires, dont la possibilitÃ© d'afficher les erreurs Ã  cÃ´tÃ© des champs.  


### `<FieldError>`

Pour celÃ , voici le composant `<FieldError>` (n'oubliez pas d'inclure l'`import` associÃ© en haut du fichier):

```javascript{8,22,26,30}
// web/src/pages/ContactPage/ContactPage.js

import {
  Form,
  TextField,
  TextAreaField,
  Submit,
  FieldError,
} from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  const onSubmit = (data) => {
    console.log(data)
  }

  return (
    <BlogLayout>
      <Form onSubmit={onSubmit}>
        <label htmlFor="name">Name</label>
        <TextField name="name" validation={{ required: true }} />
        <FieldError name="name" />

        <label htmlFor="email">Email</label>
        <TextField name="email" validation={{ required: true }} />
        <FieldError name="email" />

        <label htmlFor="message">Message</label>
        <TextAreaField name="message" validation={{ required: true }} />
        <FieldError name="message" />

        <Submit>Save</Submit>
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

Observez que l'attribut `name` correspond Ã  celui du champ au dessus. De cette maniÃ¨re, Redwood sait oÃ¹ afficher le message d'erreur d'un champ.

<img src="https://user-images.githubusercontent.com/300/80258694-ac95a400-8638-11ea-904c-dc034f07b12a.png" />

Mais c'est juste le dÃ©but. Maintenant faisons en sorte que nos utilisateurs sachent qu'il s'agisse bien d'un message d'erreur. Vous rappellez-vous la classe CSS `.error` que nous avions dÃ©finie dans `index.css`? Indiquons-la Ã  l'attribut `className` de nos composants `<FieldError>`:

```javascript{8,12,16}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Form onSubmit={onSubmit}>
      <label htmlFor="name">Name</label>
      <TextField name="name" validation={{ required: true }} />
      <FieldError name="name" className="error" />

      <label htmlFor="email">Email</label>
      <TextField name="email" validation={{ required: true }} />
      <FieldError name="email" className="error" />

      <label htmlFor="message">Message</label>
      <TextAreaField name="message" validation={{ required: true }} />
      <FieldError name="message" className="error" />

      <Submit>Save</Submit>
    </Form>
  </BlogLayout>
)
```

<img src="https://user-images.githubusercontent.com/300/73306040-3cf65100-41d0-11ea-99a9-9468bba82da7.png" />

Vous savez ce qui serez bien? Que le champ lui-mÃªme indique qu'il y a eu une erreur. Remarquez ici l'utilisation de l'attribut `errorClassName`:

```javascript{10,18,26}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Form onSubmit={onSubmit}>
      <label htmlFor="name">Name</label>
      <TextField
        name="name"
        validation={{ required: true }}
        errorClassName="error"
      />
      <FieldError name="name" className="error" />

      <label htmlFor="email">Email</label>
      <TextField
        name="email"
        validation={{ required: true }}
        errorClassName="error"
      />
      <FieldError name="email" className="error" />

      <label htmlFor="message">Message</label>
      <TextAreaField
        name="message"
        validation={{ required: true }}
        errorClassName="error"
      />
      <FieldError name="message" className="error" />

      <Submit>Save</Submit>
    </Form>
  </BlogLayout>
)
```

<img src="https://user-images.githubusercontent.com/300/80258907-39d8f880-8639-11ea-8816-03a11c69e8ac.png" />

Bravo! Et maintenant, appliquons ce principe Ã  l'Ã©tiquette elle-mÃªme. Pour celÃ  utilisons le composant `<Label>` fourni par Redwood. Notez comme l'attribut `for` correspond Ã  la valeur de l'attribut `name` du composant associÃ©. N'oubliez pas Ã©galement d'importer le composant:

```javascript{9,21-23,31-33,41-43}
// web/src/pages/ContactPage/ContactPage.js

import {
  Form,
  TextField,
  TextAreaField,
  Submit,
  FieldError,
  Label,
} from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  const onSubmit = (data) => {
    console.log(data)
  }

  return (
    <BlogLayout>
      <Form onSubmit={onSubmit}>
        <Label name="name" errorClassName="error">
          Name
        </Label>
        <TextField
          name="name"
          validation={{ required: true }}
          errorClassName="error"
        />
        <FieldError name="name" className="error" />

        <Label name="email" errorClassName="error">
          Email
        </Label>
        <TextField
          name="email"
          validation={{ required: true }}
          errorClassName="error"
        />
        <FieldError name="email" className="error" />

        <Label name="message" errorClassName="error">
          Message
        </Label>
        <TextAreaField
          name="message"
          validation={{ required: true }}
          errorClassName="error"
        />
        <FieldError name="message" className="error" />

        <Submit>Save</Submit>
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

<img src="https://user-images.githubusercontent.com/300/80259003-70af0e80-8639-11ea-97cf-b6b816118fbf.png" />

> En plus de `className` et `errorClassName` vous pouvez Ã©galement utiliser `style` et `errorStyle`

### Validation du Format des Champs

Nous devrions nous assurer que le champ email contient bien... un email!

```html{7-9}
// web/src/pages/ContactPage/ContactPage.js

<TextField
  name="email"
  validation={{
    required: true,
    pattern: {
      value: /[^@]+@[^.]+\..+/,
    },
  }}
  errorClassName="error"
/>
```

OK, Ã§a n'est pas la validation ultime pour un champ email, mais pour le moment faisons comme si. Modifions Ã©galement le message affichÃ© en cas d'Ã©chec de la validation:

```html{9}
// web/src/pages/ContactPage/ContactPage.js

<TextField
  name="email"
  validation={{
    required: true,
    pattern: {
      value: /[^@]+@[^.]+\..+/,
      message: 'Please enter a valid email address',
    },
  }}
  errorClassName="error"
/>
```

<img src="https://user-images.githubusercontent.com/300/80259139-bd92e500-8639-11ea-99d5-be278dc67afc.png" />

Vous avez peut-Ãªtre remarquÃ© qu'essayer d'envoyer le formulaire alors que sont prÃ©sentes des erreurs de validation n'affiche rien dans la console. C'est en rÃ©alitÃ© une bonne chose car celÃ  vous indique que le formulaire n'a pas Ã©tÃ© envoyÃ©. Corrigez la valeur des champs concernÃ©s, et tout fonctionne correctement.

> Lorsqu'un message liÃ© Ã  une erreur lors de la validation d'un champ s'affiche, il disparaÃ®t dÃ¨s que la valeur est corrigÃ©e. Ainsi l'utilisateur n'a pas Ã  devoir envoyer de nouveau le formulaire pour vÃ©rifier la validitÃ© de la saisie.

Finalement, savez-vous ce qui serait _vraiment_ sympa? Ce serait de faire en sorte que les champs soient validÃ©s dÃ¨s que l'utilisateur quitte un champ. De cette maniÃ¨re l'utilisateur n'a pas besoin de remplir l'ensemble des champs et envoyer le formulaire pour voir toutes les erreurs s'afficher. Voyons comment faire:

```html
// web/src/pages/ContactPage/ContactPage.js

<Form onSubmit={onSubmit} validation={{ mode: 'onBlur' }}>
```

Alors, qu'en pensez-vous? Quelques composants, un ou deux attributs, et vous avez devant vous un formulaire qui gÃ¨re les erreurs, valide les champs et vous envoie le contenu sous la forme d'un bel objet javascript. Merci Redwood!

> Les formulaires de Redwood sont construits Ã  partir de la librairie [React Hook Form](https://react-hook-form.com/). Celle-ci contient d'autres fonctionalitÃ©s trÃ¨s utiles que nous n'avons pas documentÃ© ici.  

Redwood a encore plus d'un tour dans son sac pour ce qui concerne les formulaires, mais nous allons garder Ã§a pour une Ã©tape ultÃ©rieure.

Avoir un formulaire de contact, c'est bien. Mais conserver les message qu'on vous envoie, c'est mieux! ProcÃ©dons maintenant Ã  la crÃ©ation de la table en base de donnÃ©es pour y enregistrer ces informations. Ce faisant nous allons crÃ©er notre premiÃ¨re mutation GraphQL!

## Enregistrer les DonnÃ©es

Ajoutons une nouvelle table Ã  notre base de donnÃ©es. Ouvrez `api/prisma/schema.prisma` et ajoutez un nouveau modÃ¨le "Contact" Ã  la suite du premier modÃ¨le "Post": 

```javascript
// api/prisma/schema.prisma

model Contact {
  id        Int @id @default(autoincrement())
  name      String
  email     String
  message   String
  createdAt DateTime @default(now())
}
```

> Pour dÃ©finir une colonne comme optionnelle (c'est Ã  dire permettre que sa valeur soit `NULL`), il suffit de suffixer le type de la donnÃ©e avec un point d'interrogation: `name String?` 

Nous crÃ©ons ensuite notre nouvelle migration:

    yarn rw db save create contact

Enfin, nous executons la migration de faÃ§on Ã  mettre Ã  jour le schÃ©ma de la base de donnÃ©es:

    yarn rw db up

Maintenant nous crÃ©eons l'interface GraphQL permettant d'accÃ©der Ã  cette nouvelle table. C'est la premiÃ¨re fois que nous utilisons cette commande `generate` nous mÃªme. (la commande `scaffold` repose Ã©galement dessus):

    yarn rw g sdl contact

De la mÃªme maniÃ¨re qu'avec la commande `scaffold`, ceci va crÃ©er deux nouveaux fichiers dans le rÃ©pertoire `api`:

1. `api/src/graphql/contacts.sdl.js`: qui dÃ©finit le schÃ©ma GraphQL
2. `api/src/services/contacts/contacts.js`: qui contient votre code mÃ©tier

Ouvrez `api/src/graphql/contacts.sdl.js` et vous verrez les types `Contact`, `CreateContactInput` et `UpdateContactInput` dÃ©jÃ  dÃ©finis pour vous. La commande `generate sdl` a analysÃ© le schÃ©ma et crÃ©Ã© un type `Contact` contenant chaque champ de la table, ainsi qu'un type `Query` avec une requÃªte `contacts` qui retourne un tableau de types `Contact`.

```javascript
// api/src/graphql/contacts.sdl.js

export const schema = gql`
  type Contact {
    id: Int!
    name: String!
    email: String!
    message: String!
    createdAt: DateTime!
  }

  type Query {
    contacts: [Contact!]!
  }

  input CreateContactInput {
    name: String!
    email: String!
    message: String!
  }

  input UpdateContactInput {
    name: String
    email: String
    message: String
  }
`
```

Que sont les "input" `CreateContactInput` et `UpdateContactInput`? Redwood suit la recommandation de GraphQL d'utiliser les [Input Types](https://graphql.org/graphql-js/mutations-and-input-types/) dans les mutations plutÃ´t que de lister tous les champs qui peuvent Ãªtre dÃ©finis. Tous les champs requis dans `schema.prisma` sont Ã©galement requis dans `CreateContactInput` (vous ne pouvez pas crÃ©er un enregistrement valide sans eux) mais rien n'est explicitement requis dans `UpdateContactInput`. En effet, vous pouvez souhaiter mettre Ã  jour un seul champ, deux champs ou tous les champs. L'alternative serait de crÃ©er des types d'entrÃ©e sÃ©parÃ©s pour chaque permutation de champs que vous souhaitez mettre Ã  jour. Nous avons estimÃ© que le fait de n'avoir qu'une seule entrÃ©e de mise Ã  jour, bien que ce ne soit peut-Ãªtre pas la maniÃ¨re absolument correcte de crÃ©er une API GraphQL, Ã©tait un bon compromis pour faciliter le dÃ©veloppement.

> Redwood suppose que votre code n'essaiera pas de dÃ©finir une valeur sur un champ nommÃ© `id` ou `createdAt` donc il les a laissÃ©s en dehors des types d'entrÃ©e, mais si votre base de donnÃ©es autorise l'un ou l'autre de ceux Ã  dÃ©finir manuellement, vous pouvez mettre Ã  jour` CreateContactInput `ou `UpdateContactInput` et les ajouter.

Puisque toutes les colonnes de la table Ã©taient dÃ©finies comme requises dans `schema.prisma`, elles sont Ã©galement dÃ©finies comme requises ici (notez le suffixe `!` sur les types de donnÃ©es)

> **important:** la syntaxe de `schema.prisma` requiert l'ajout d'un caractÃ¨re `?` lorsqu'un champ _n'est pas_ requis, tandis que la syntaxe GraphQL requiert l'ajout d'un caractÃ¨re `!` lorsqu'un champ _est_ requis.

Comme dÃ©crit dans [QuÃªte secondaire: Fonctionnement de Redwood avec les DonnÃ©es](qu-te-secondaire-fonctionnement-de-redwood-avec-les-donn-es), il n'y a pas de "resolver" dÃ©finit explicitement dans le fichier SDL. Redwood suit une convention de nommage simple: chaque champ listÃ© dans les types `Query` et `Mutation` correspondent Ã  une fonction avec un nom identique dans les fichiers `service` et `sdl` associÃ©s (`api/src/graphql/contacts.sdl.js -> api/src/services/contacts/contacts.js`) 

Dans le cas prÃ©sent, nous crÃ©eons une unique `Mutation` que nous appelons `createContact`. Nous l'ajoutons Ã  la fin de notre fichier SDL (avant le caractÃ¨re 'backtick'): 

```javascript
// api/src/graphql/contacts.sdl.js

type Mutation {
  createContact(input: CreateContactInput!): Contact
}
```

La mutation `createContact` accepte une variable unique, `input`, qui est un objet conforme Ã  ce qu'on attend pour un `CreateContactInput`, c'est Ã  dire `{ name, email, message }`.

C'est terminÃ© pour le fichier SDL, dÃ©finissons maintenant le service qui va rÃ©ellement enregistrer les donnÃ©es en base. Le service inclut une fonction `contacts` permettant de rÃ©cupÃ©rer l'ensemble des contacts depuis la base. Ajoutons-y une mutation pour pouvoir crÃ©er un nouveau contact:

```javascript{9-11}
// api/src/services/contacts/contacts.js

import { db } from 'src/lib/db'

export const contacts = () => {
  return db.contact.findMany()
}

export const createContact = ({ input }) => {
  return db.contact.create({ data: input })
}
```

GrÃ¢ce au client Prisma, il faut peu de code pour enregistrer nos donnÃ©es en base! Il s'agit d'un appel asynchrone, mais nous n'avons pas Ã  nous soucier de manipuler un objet Promise ou s'arranger avec `async/await`. La librairie Apollo le fait pour nous!

Avant d'insÃ©rer tout ceci dans notre interface utilisateur, prennons un peu de temps pour utiliser un outil bien pratique en exÃ©cutant la commande `yarn redwood dev`.

### Le Bac Ã  Sable GraphQL

Souvent, il est utile d'expÃ©rimenter notre API dans une forme un peu "brute" avant de poursuivre plus avant le dÃ©veloppement de l'interface et s'apercevoir que l'on a oubliÃ© quelque chose.

Lorsque vous avez exÃ©cutÃ© la commande `yarn redwood dev` au dÃ©but de ce didacticiel, vous avez en rÃ©alitÃ© dÃ©marrÃ© un second processus en arriÃ¨re-plan. Ouvrez donc une nouvelle page de votre navigateur Ã  cette adresse: http://localhost:8911/graphql . Il s'agit du [Bac Ã  Sable GraphQL](https://github.com/prisma-labs/graphql-playground) fournit par la librairie Prisma, une application web permettant d'interagir avec une API GraphQL: 

<img src="https://user-images.githubusercontent.com/300/70950852-9b97af00-2016-11ea-9550-b6983ce664e2.png" />

Observez en particulier l'onglet "Doc" situÃ© sur la partie droite de l'Ã©cran:

<img src="https://user-images.githubusercontent.com/300/73311311-fce89b80-41da-11ea-9a7f-2ef6b8191052.png" />

Vous y trouverez le schema complet tel que dÃ©finit dans vos fichiers SDL! L'application analyse ces dÃ©finitions et vous propose ces Ã©lÃ©ments pour vous permettre de construire vos requÃªtes. Essayez par exemple de rÃ©cupÃ©rer les ID de tous les articles en Ã©crivant votre requÃªte dans la partie gauche puis en cliquant sur le bouton "Play":

<img src="https://user-images.githubusercontent.com/300/70951466-52e0f580-2018-11ea-91d6-5a5712858781.png" />

Le bac Ã  sable GraphQL est une excellente maniÃ¨re d'expÃ©rimenter avec votre API, et comprendre pourquoi une requÃªte ne fonctionne pas comme prÃ©vue.

### CrÃ©er un Contact

Notre mutation GraphQL est prÃªte pour la partie backend, tout ce qu'il reste Ã  faire c'est l'invoquer depuis la partie frontend. Tout ce qui Ã  trait Ã  notre formulaire se trouve dans `ContactPage`, c'est donc l'endroit logique pour y mettre l'appel Ã  notre nouvelle mutation. D'abord nous dÃ©finissons cette mutation comme une constante que nous appellerons plus tard (ceci peut Ãªtre dÃ©fini en dehors du composant lui-mÃªme, juste aprÃ¨s les lignes d'imports):

```javascript
// web/src/pages/ContactPage/ContactPage.js

const CREATE_CONTACT = gql`
  mutation CreateContactMutation($input: CreateContactInput!) {
    createContact(input: $input) {
      id
    }
  }
`
```

Nous rÃ©fÃ©renÃ§ons ainsi la mutation `createContact` dÃ©finie auparavant dans le fichier SDL des contacts, tout en lui passant en argument un objet `input` contenant la valeur des champs `name`, `email` et `message`.

AprÃ¨s quoi, nous appelons le 'hook' `useMutation` fourni par Appolo, ce qui nous permet d'exÃ©cuter la mutation lorsque le moment est venu (n'oubliez pas les imports comme Ã  chaque fois):

```javascript{11,15}
// web/src/pages/ContactPage/ContactPage.js

import {
  Form,
  TextField,
  TextAreaField,
  Submit,
  FieldError,
  Label,
} from '@redwoodjs/forms'
import { useMutation } from '@redwoodjs/web'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  const [create] = useMutation(CREATE_CONTACT)

  const onSubmit = (data) => {
    console.log(data)
  }

  return (...)
}
```
`create` est une fonction qui invoque la mutation et prend en paramÃ¨tre un objet contenant un clef `variables`. Cette derniÃ¨re contient Ã  son tour une clef `input`. Par exemple, nous pourrions l'appeler Ã©galement de cette maniÃ¨re:

```javascript
create({
  variables: {
    input: {
      name: 'Rob',
      email: 'rob@redwoodjs.com',
      message: 'I love Redwood!',
    },
  },
})
```

Si votre mÃ©Ã©moire est bonne, vous vous souvenez sans doute que la balise `<Form>` nous donne accÃ¨s Ã  l'ensemble des champs du formulaire avec un objet bien pratique dans lequel chaque clef se trouve Ãªtre le nom du champ. CelÃ  signifie donc que l'objet `data`que nous recevons dans `onSubmit` est dÃ©jÃ  dans le format adaptÃ© pour `input`!  

Maintenant nous pouvons mettre Ã  jour la fonction `onSubmit` pour invoquer la mutation avec les donnÃ©es qu'elle reÃ§oit:

```javascript{7}
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = () => {
  const [create] = useMutation(CREATE_CONTACT)

  const onSubmit = (data) => {
    create({ variables: { input: data }})
    console.log(data)
  }

  return (...)
}
```

Essayez-donc de remplir le formulaire et de l'envoyer. Vous devriez obtenir un nouveau contact en base de donnÃ©es! Vous pouvez vÃ©rifier ceci avec l'outil bac Ã  sable de GraphQL:

![image](https://user-images.githubusercontent.com/300/76250632-ed5d6900-6202-11ea-94ce-bd88e3a11ade.png)

### AmÃ©liorer le formulaire de contact

Notre formulaire de contact fonctionne, mais il subsiste quelques problÃ¨mes:

- Cliquer sur le bouton d'enregistrement plusieurs fois Ã  pour consÃ©quence d'envoyer le formulaire Ã©galement plusieurs fois
- L'utilisateur ne sait pas si l'envoi a bien Ã©tÃ© pris en compte
- Si une erreur devait se produire cÃ´tÃ© serveur, nous n'avons aucun moyen d'en informer l'utilisateur

Essayons d'y apporter une solution.

Le 'hook' `useMutation` retourne quelques autres Ã©lÃ©ments en plus de la fonction permettant de l'invoquer. Nous pouvons dÃ©structurer ceux-ci (`loading` et `error`) de la faÃ§on suivante:

```javascript{4}
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = () => {
  const [create, { loading, error }] = useMutation(CREATE_CONTACT)

  const onSubmit = (data) => {
    create({ variables: { input: data } })
    console.log(data)
  }

  return (...)
}
```

Ce faisant, nous savons si un appel Ã  la base est toujours en cours en utilisant la valeur de `loading`. Une faÃ§on simple de rÃ©soudre le problÃ¨me des soumissions multiples du mÃªme formulaire est de rendre inactif le bouton d'envoi tant que la rÃ©ponse n'a pas Ã©tÃ© reÃ§ue. Nous pouvons faire celÃ  en liant l'attribut `disabled` du bouton "save" Ã  la valeur contanue dans `loading`:

```javascript{5}
// web/src/pages/ContactPage/ContactPage.js

return (
  // ...
  <Submit disabled={loading}>Save</Submit>
  // ...
)
```

Il peut Ãªtre difficile de voir une diffÃ©rence en phase de dÃ©veloppement car l'envoi est trÃ¨s rapide. Mais vous pouvez nÃ©anmoins activer un outil bien pratique dans le navigateur Chrome afin de simuler une connection lente:

<img src="https://user-images.githubusercontent.com/300/71037869-6dc56f80-20d5-11ea-8b26-3dadb8a1ed86.png" />

Vous verrez alors que le bouton "Save" devient inactif pendant une seconde ou deux en attendant la rÃ©ponse.

Maintenant, utilisons le systÃ¨me dit de `Flash` proposÃ© par Redwood afin d'informer l'utilisateur que son envoi Ã  bien Ã©tÃ© traitÃ©. `useMutation` accepte un second paramÃ¨tre optionnel contenant des options. Une de ces options est une fonction callback appelÃ©e `onCompleted` qui sera invoquÃ©e lorsque la mutation sera achevÃ©e avec succÃ¨s. Nous allons donc utiliser cette fonction pour ajouter un message qui sera affichÃ© par un composant `Flash`. Ajoutez donc le composant `Flash` a votre page et utilisez sa propriÃ©tÃ© `timeout` pour dÃ©finir le temps d'affichage. (Vous pouvez lire la documentation Ã  propos du systÃ¨me de Flash proposÃ© par Redwood [ici](https://redwoodjs.com/docs/flash-messaging-bus))

```javascript{4,10,13-17,24}
// web/src/pages/ContactPage/ContactPage.js

// ...
import { Flash, useFlash, useMutation } from '@redwoodjs/web'
import BlogLayout from 'src/layouts/BlogLayout'

// ...

const ContactPage = () => {
  const { addMessage } = useFlash()

  const [create, { loading, error }] = useMutation(CREATE_CONTACT, {
    onCompleted: () => {
      addMessage('Thank you for your submission!', {
        style: { backgroundColor: 'green', color: 'white', padding: '1rem' }
      })
    },
  })

  // ...

  return (
    <BlogLayout>
      <Flash timeout={2000} />
      // ...
```

### Afficher les erreurs serveur

Nous allons maintenant informer l'utilisateur des Ã©ventuelles erreurs cÃ´tÃ© serveur. Jusqu'ici nous n'avons notifiÃ© les utilisateurs quie des erreurs _cÃ´tÃ© client_ lorsqu'un champ Ã©tait manquant ou formatÃ© incorrectement. Mais si nous avons Ã©galement des contraintes cÃ´tÃ© serveur que le composant `<Form>` ignore, nous devons tout de mÃªme pouvoir en informer l'utilisateur.

Ainsi, nous avons une validateur de l'email cÃ´tÃ© client, mais tout bon dÃ©veloppeur web sait qu'il ne faut [_jamais faire confiance au client_](https://www.codebyamir.com/blog/never-trust-data-from-the-browser). Ajoutons une validation de l'email cÃ´tÃ© serveur de faÃ§on Ã  Ãªtre certain qu'aucune donnÃ©e erronÃ©e ne soit ajoutÃ©e dans la base, et ce mÃªme si un utilisateur parvenait Ã  contourner le fonctionnement de l'application cÃ´tÃ© client.

> Pourquoi n'avons-nous pas besoin de validation cÃ´tÃ© serveur pour s'assurer que les champs name, email et message sont bien remplis? Car la base de donnÃ©es le fait pour nous. Vous rappellez-vous `String!` dans notre fichier SDL? CelÃ  ajoute une contrainte en base de donnÃ©es de telle faÃ§on que ce champ ne puisse Ãªtre `null`. Une valeur `null` serait rejetÃ©e par la base et GraphQL renverrait une erreur Ã  la partie client. 
>
> Cependant, il n'existe pas de type `Email!`, raison pour laquelle nous devons assurer la validation nous mÃªme 

Nous avons dÃ©jÃ  parlÃ© de code mÃ©tier et du fait que ce type de code a vocation Ã  se trouver dans nos fichiers services. Ceci en est un exemple parfait. Ajoutons une fonction `validate` Ã  notre service `contacts`:

```javascript{3,7-15,22}
// api/src/services/contacts/contacts.js

import { UserInputError } from '@redwoodjs/api'

import { db } from 'src/lib/db'

const validate = (input) => {
  if (input.email && !input.email.match(/[^@]+@[^.]+\..+/)) {
    throw new UserInputError("Can't create new contact", {
      messages: {
        email: ['is not formatted like an email address'],
      },
    })
  }
}

export const contacts = () => {
  return db.contact.findMany()
}

export const createContact = ({ input }) => {
  validate(input)
  return db.contact.create({ data: input })
}
```

Ainsi, lorsque `createContact` est invoquÃ©e, la fonction commence par valider le contenu des champs du formulaire. Puis, et seulement s'il n'y a aucune erreur, l'enregistrement sera crÃ©Ã© en base de donnÃ©es.

Nous capturons dÃ©jÃ  toutes les erreurs dans la constante `error` que nous obtenons grÃ¢ce au 'hook' `useMutation`. C'est pourquoi nous avons la possibilitÃ© d'afficher ces erreurs sur la page, par exemple au dessus du formulaire:

```html{4-9}
// web/src/pages/ContactPage/ContactPage.js

<Form onSubmit={onSubmit} validation={{ mode: 'onBlur' }}>
  {error && (
    <div style={{ color: 'red' }}>
      {"We couldn't send your message: "}
      {error.message}
    </div>
  )}
  // ...
```

> Si vous avez besoin de manipuler l'objet contenant les erreurs, vous pouvez procÃ©der ainsi:
>
> ```javascript{3-8}
> // web/src/pages/ContactPage/ContactPage.js
> const onSubmit = async (data) => {
>   try {
>     await create({ variables: { input: data } })
>     console.log(data)
>   } catch (error) {
>     console.log(error)
>   }
> }
> ```

Afin de tester ceci, provoquons une erreur en retirant temporairement la validation cÃ´tÃ© client de l'adresse email:

```html
// web/src/pages/ContactPage/ContactPage.js

<TextField
  name="email"
  validation={{
    required: true,
  }}
  errorClassName="error"
/>
```

Maintenant, essayons de remplir le formulaire avec un adresse invalide:

<img src="https://user-images.githubusercontent.com/300/80259406-5aee1900-863a-11ea-9b82-def3a4f3e162.png" />

CelÃ  fonctionne, mÃªme si l'affichage reste Ã  amÃ©liorer. Voir apparaÃ®tre une erreur GraphQL n'est pas idÃ©al. Il serait plus sympa de faire en sorte que ce soit le champ concernÃ© qui soit marquÃ© d'une erreur...

Vous rapellez-vous lorsque nous avons dit que `<Form>` avait plus d'un tour dans son sac? Voyons donc Ã§a!

Supprimez l'affichage de l'erreur tel que nous venons de l'ajouter (`{ error && ...}`) , et remplacez-le avec `<FormError>` tout en passant en argument la constante `error` que nous rÃ©cupÃ©rons depuis `useMutation`. Ajoutez Ã©galement quelques Ã©Ã©lÃ©ments de style Ã  `wrapperStyle`, sans oublier les `import` associÃ©s.

```javascript{10,18-22}
// web/src/pages/ContactPage/ContactPage.js

import {
  Form,
  TextField,
  TextAreaField,
  Submit,
  FieldError,
  Label,
  FormError,
} from '@redwoodjs/forms'
import { Flash, useFlash, useMutation } from '@redwoodjs/web'
// ...

return (
  <BlogLayout>
    <Flash timeout={1000}>
    <Form onSubmit={onSubmit} validation={{ mode: 'onBlur' }} error={error}>
      <FormError
        error={error}
        wrapperStyle={{ color: 'red', backgroundColor: 'lavenderblush' }}
      />

      //...
)
```

DÃ©sormais, l'envoi du formulaire avec une adresse invalide donne ceci:

<img src="https://user-images.githubusercontent.com/300/80259553-c46e2780-863a-11ea-9441-54a9112b9ce5.png" />

Nous obtenons un message d'erreur en haut du formulaire _et_ les champs concernÃ©s sont mis en avant! Le message en haut du formulaire peut apparaÃ®tre un peu lourd pour un si petit formulaire, mais vous contaterez son utilitÃ© lorsque vous construirez des formulaires de plusieurs pages; de cette faÃ§on l'utilisateur peut voir immÃ©Ã©diatement ce qui ne fonctionne pas sans avoir Ã  parcourir l'ensemble du formulaire. Si vous ne souhaitez pas utiliser cet affichage, il vous suffit de supprimer `<FormError>`, les champs seront toujours mis en avant.

> `<FormError>` a plusieurs options pour adapter le style d'affichage
>
> - `wrapperStyle` / `wrapperClassName`: le conteneur pour l'ensemble du message
> - `titleStyle` / `titleClassName`: le titre "Can't create new contact"
> - `listStyle` / `listClassName`: le `<ul>` qui contient la liste des erreurs
> - `listItemStyle` / `listItemClassName`: chaque `<li>` contenant chaque erreur

### One more thing...

Puisque nous ne redirigeons pas l'utilisateur une fois le formulaire envoyÃ©, nous devrions au moins remettre le formulaire Ã  zÃ©ro. Pour celÃ  nous devons utiliser la fonction `reset()` proposÃ©e par `react-hook-form`, mais nous n'y avons pas accÃ¨s compte tenu de la maniÃ¨re dont nous utilisons `<Form>`.

`react-hook-form` possÃ¨de un 'hook' appelÃ© `useForm()` qui est en principe invoquÃ©Ã© pour nous Ã  l'intÃ©rieur de `<Form>`. De faÃ§on Ã  rÃ©initialiser le formulaire nous devons invoquer ce 'hook' manuellement. Voici comment faire:

CommenÃ§ons par importer `useForm`:

```javascript
// web/src/pages/ContactPage/ContactPage.js

import { useForm } from 'react-hook-form'
```

Puis invoquons ce 'hook' dans notre composant:

```javascript{4}
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = () => {
  const formMethods = useForm()
  //...
```

Enfin, donnons pour instruction explicite Ã  `<Form>` d'utiliser `formMethods`, au lieu de le laisser le faire lui-mÃªme:

```javascript{10}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Flash timeout={1000}>
    <Form
      onSubmit={onSubmit}
      validation={{ mode: 'onBlur' }}
      error={error}
      formMethods={formMethods}
    >
    // ...
```

Maintenant nous pouvons invoquer manuellement `reset()` depuis `formMethods()` juste aprÃ¨s que le message de confirmation soit affichÃ©:

```javascript
// web/src/pages/ContactPage/ContactPage.js

const [create, { loading, error }] = useMutation(CREATE_CONTACT, {
  onCompleted: () => {
    // addMessage...
    formMethods.reset()
  },
})
```

<img alt="Capture Ã©cran du formulaire de Contact avec message de confirmation Flash" src="https://user-images.githubusercontent.com/44448047/93649232-1be9a700-f9d1-11ea-821c-7a69c626f50c.png">

> Vous pouvez maintenant rÃ©activer la validation email cÃ´tÃ© client sur le `<TextField>`, tout en conservant la validation cÃ´tÃ© serveur.

Voici le contenu final de la page `ContactPage.js`: 

```javascript
import {
  Form,
  TextField,
  TextAreaField,
  Submit,
  FieldError,
  Label,
  FormError,
} from '@redwoodjs/forms'
import { Flash, useFlash, useMutation } from '@redwoodjs/web'
import { useForm } from 'react-hook-form'
import BlogLayout from 'src/layouts/BlogLayout'

const CREATE_CONTACT = gql`
  mutation CreateContactMutation($input: CreateContactInput!) {
    createContact(input: $input) {
      id
    }
  }
`

const ContactPage = () => {
  const formMethods = useForm()
  const { addMessage } = useFlash()

  const [create, { loading, error }] = useMutation(CREATE_CONTACT, {
    onCompleted: () => {
      addMessage('Thank you for your submission!', {
        style: { backgroundColor: 'green', color: 'white', padding: '1rem' }
      })
      formMethods.reset()
    },
  })

  const onSubmit = (data) => {
    create({ variables: { input: data } })
    console.log(data)
  }

  return (
    <BlogLayout>
      <Flash timeout={1000} />
      <Form
        onSubmit={onSubmit}
        validation={{ mode: 'onBlur' }}
        error={error}
        formMethods={formMethods}
      >
        <FormError
          error={error}
          wrapperStyle={{ color: 'red', backgroundColor: 'lavenderblush' }}
        />
        <Label name="name" errorClassName="error">
          Name
        </Label>
        <TextField
          name="name"
          validation={{ required: true }}
          errorClassName="error"
        />
        <FieldError name="name" className="error" />

        <Label name="name" errorClassName="error">
          Email
        </Label>
        <TextField
          name="email"
          validation={{
            required: true,
          }}
          errorClassName="error"
        />
        <FieldError name="email" className="error" />

        <Label name="name" errorClassName="error">
          Message
        </Label>
        <TextAreaField
          name="message"
          validation={{ required: true }}
          errorClassName="error"
        />
        <FieldError name="message" className="error" />

        <Submit disabled={loading}>Save</Submit>
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

C'est terminÃ©! [React Hook Form](https://react-hook-form.com/) propose pas mal de fonctionalitÃ©s que `<Form>` n'expose pas. Lorsque vous souhaitez les utiliser, appelez juste le 'hook' `useForm()` vous-mÃªme, en vous assurant de bien passer en argument l'objet retournÃ© (`formMethods`) comme propriÃ©tÃ© de `<Form>` de faÃ§on Ã  ce que la validation et les autres fonctionalitÃ©s puissent continuer Ã  fonctionner. 

> Vous avez peut-Ãªtre remarquÃ© que la validation onBlur a cessÃ© de fonctionner lorsque vous avez commencÃ© Ã  appeler `userForm()` par vous-mÃªme. Ceci s'explique car Redwood invoque `userForm()` et lui passe automatiquement en argument ce que vous avez passÃ© Ã  `<Form>`. Puisque Redwood n'appelle plus automatiquement `useForm()` Ã  votre place, vous devez de faire manuellement:
>
> ```javascript
> const formMethods = useForm({ mode: 'onBlur' })
> ```

La partie publique du site a bon aspect. Que faire maintenant de la partie administration qui nous permet de crÃ©er et Ã©diter les articles? Nous devrions la dÃ©placer dans une partie rÃ©servÃ©e et la placer derriÃ¨re un login, de faÃ§on Ã  ce des utilisateurs mal intentionnÃ©s ne puissent pas crÃ©er en chaÃ®ne, par exemple, des publicitÃ©s pour l'achat de mÃ©dicaments en ligne...

## Administration

Il semble raisonable de faire en sorte que les Ã©crans d'administration soient regroupÃ©s sous un chemin `/admin`. Mettons Ã  jour les routes de maniÃ¨re Ã  ce que les quatre routes commenÃ§ant par `/posts` commencent dÃ©sormais paar `/admin/posts`:

```html
// web/src/Routes.js

<Route path="/admin/posts/new" page={NewPostPage} name="newPost" />
<Route path="/admin/posts/{id:Int}/edit" page={EditPostPage} name="editPost" />
<Route path="/admin/posts/{id:Int}" page={PostPage} name="post" />
<Route path="/admin/posts" page={PostsPage} name="posts" />
```

Allez Ã  http://localhost:8910/admin/posts et notre page gÃ©nÃ©rÃ©e par scaffolding devrait s'afficher. GrÃ¢ce aux routes nommÃ©es, nous n'avons pas Ã  mettre Ã  jour les `<Link>` crÃ©Ã©s lors du scaffold puisque l'attribut `name` reste identique!


> Sur la derniÃ¨re page nous avons mentionnÃ© que nous allions crÃ©er une section admin **et** la mettre derriÃ¨re un login. Jusqu'Ã  maintenant nous n'avons fait que modifier les routes. Ne vous inquiÃ©tez pas, nous n'avons pas oubliÃ©! Nous allons mettre en place l'authentification dans une [prochaine Ã©tape](/tutorial/authentication).

Que pensez-vous de mettre enfin en ligne tout ce que nous avons rÃ©alisÃ© ?

## DÃ©ploiement

La partie 4 de ce didacticiel en vidÃ©o se trouve ici:

<div class="relative pb-9/16">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/UpD3HyuZkvY?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

La raison principale pour laquelle nous avons mis au point Redwood Ã©tait de permettre aux dÃ©veloppeurs de construire des applications web _full-stack_ plus facilement tout en adhÃ©rant Ã  la philosophie Jamstack. Vous avez pu voir Ã  quoi ressemble l'Ã©laboration d'une application Redwood. Que pensez-vous de voir comment on la dÃ©ploit?

Il n'y a qu'une modification Ã  faire pour que notre application soit prÃªte Ã  Ãªtre dÃ©ployÃ©e, et bien entendu nous avons un gÃ©nÃ©rateur pour Ã§a:

```terminal
yarn rw g deploy netlify
```

L'exÃ©cution de cette commande va crÃ©er un fichier `/netlify.toml` contenant les commandes et les chemins de fichiers dont Netlify a besoin afin de construire l'application.

Avant que nous ne poursuivions, assurez-vous que tous les commits soient faits et bien envoyÃ©s sur GitHub, GitLab or BitBucket. En effet, nous allons lier Netlify Ã  notre dÃ©pÃ´t Git de faÃ§on Ã  ce tout nouveau push sur la branch `main` permette de re-dÃ©ployer le site. Si vous n'avez jamais travaillÃ© auparavant avec une application Jamstack, prÃ©parez-vous Ã  une sympatique expÃ©rience!

> **NOTE:** Git utilise par dÃ©faut une branche `master`. Vous ne savez pas comment renommer `master` en `main`? Si vous utilisez GitHub, vous pouvez suivre ces Ã©tapes:
>
> ```plaintext{4,6}
> git init
> git add .
> git commit -m 'First commit'
> git branch -m main
> git remote add origin ...
> git push -u origin main
> ```

### Vercel (cible de dÃ©ploiement alternative)

Redwood supporte officiellement plusieurs fournisseurs d'hÃ©bergement (et d'autres sont en cours d'ajout). Bien que ce didacticiel se poursuive en s'appuyant sur Netlify pour le dÃ©ploiement et l'authentification, il vous est possible de dÃ©ployer sur [Vercel](https://vercel.com/redwoodjs-core). Pour cela, commencer par achever la section suivante ("La Base de DonnÃ©es"), mais utilisez ce [guide de dÃ©ploiement Vercel](https://redwoodjs.com/docs/deploy#redwood-deploy-configuration) Ã  la place des instructions dÃ©diÃ©es Ã  Netlify. **Note**: Netlify Identity, used in the upcoming "Authentication" section, won't work on the Vercel platform.  

### La Base de DonnÃ©es

Nous avons besoin d'une base de donnÃ©es quelque part sur Internet afin d'enregistrer nos donnÃ©es. Nous avons utilisÃ© SQLite pendant la phase de dÃ©veloppement, mais il s'agit d'un outil pensÃ© pour Ãªtre utilisÃ© par un seul utilisateur. SQLite n'est pas vraiment adaptÃ© pour le type de connections concurrentes qu'une application requiert lorsqu'elle entre en production. Pour cette partie du didacticiel, nous utiliserons Postgres. (Prisma supporte Ã  ce jour SQLite, Postgres et MySQL). Ne vous inquiÃ©tez pas si vous n'Ãªtes pas familier de Postgres, Prisma va se charger de tout Ã§a. Tout ce dont nous avons besoin c'est une base de donnÃ©es qui soit accessible depuis Internet, de telle maniÃ¨re que notre application puisse s'y connecter.

Tout d'abord, nous allons informer Prisma que nous souhaitons utiliser Postgres en plkus de SQLite, de telle maniÃ¨re que Prisma va construire un client pour ces deux bases de donnÃ©es. Mettez Ã  jour l'entrÃ©e `provider` dans `schema.prisma`:

```javascript
provider = ["sqlite", "postgresql"]
```

Si vous souhaitez dÃ©velopper en local avec Postgres, [consultez le guide](/docs/local-postgres-setup). 

> Pour l'instant, vous avez besoin de crÃ©er votre propre base de donnÃ©es, mais nous travaillons avec diffÃ©rents fournisseurs d'infrastructure pour mettre un place un processus plus simple et plus en phase avec la Jamstack. Plus d'informations sont Ã  venir sur ce point!

Il existe diffÃ©rents fournisseurs d'hÃ©bergement qui vous permettent de crÃ©er rapidement une base de donnÃ©es Postgres:

- [Heroku](https://www.heroku.com/postgres)
- [Digital Ocean](https://www.digitalocean.com/products/managed-databases)
- [AWS](https://aws.amazon.com/rds/postgresql/)

Nous allons ici utiliser Heroku car 1) c'est gratuit, 2) plus facile Ã  manipuler qu'AWS pour un nÃ©ophyte.

Rendez-vous sur le site d'[Heroku](https://signup.heroku.com/), crÃ©ez un nouveau compte ou identifiez-vous. Cliquez ensuite sur le boutton **create new app**.

<img alt="Screen Shot 2020-02-03 at 3 22 36 PM" src="https://user-images.githubusercontent.com/300/73703866-438c3900-46a6-11ea-9a90-bdab2fed8bff.png">

Donnez lui un nom comme "redwoodblog". Puis allez sur l'onglet **Ressources** et cliquez sur le bouton **Find more add-ons** dans la section **Add-ons**: 

<img alt="Screen Shot 2020-02-03 at 3 23 25 PM" src="https://user-images.githubusercontent.com/300/73703877-4e46ce00-46a6-11ea-87c0-079346f4d9b3.png">

DÃ©placez-vous dans la page jusqu'Ã  faire apparaÃ®tre **Heroku Postgres**:

<img alt="Screen Shot 2020-02-03 at 3 23 48 PM" src="https://user-images.githubusercontent.com/300/73703883-556ddc00-46a6-11ea-8777-ee27d2202e0e.png">

Une page de dÃ©tail apparaÃ®t. Cliquez sur **Install Heroku Postgres** dans le coin supÃ©rieur droit. Sur l'Ã©cran suivant, prÃ©cisez que vous souhaitez connecter la base Ã  l'application que vous venez de crÃ©er. Cliquez enfin sur **Provision Add-on**.

<img alt="Screen Shot 2020-02-03 at 3 24 15 PM" src="https://user-images.githubusercontent.com/300/73703930-64548e80-46a6-11ea-9f1b-e06a183834f4.png">

Vous Ãªtes alors redirigÃ© sur la page prÃ©sentant les dÃ©tails de votre application. Vous devriez alors pouvoir aller sur l'onglet **Resources** et constater que l'add-on Heroku Postgres et prÃªt Ã  Ãªtre utilisÃ©:

<img alt="Screen Shot 2020-02-03 at 3 24 43 PM" src="https://user-images.githubusercontent.com/300/73703951-6ae30600-46a6-11ea-8d9b-a900b7af2ac5.png">

Cliquez sur le lien Heroku Postgres pour vous rendre sur la page de dÃ©tail, puis sur l'onglet **Settings** et enfin cliquez sur le boutton **View Credentials...**. Copiez l'URI situÃ©e en bas de la page.

<img alt="Screen Shot 2020-02-03 at 3 25 31 PM" src="https://user-images.githubusercontent.com/300/73703956-70405080-46a6-11ea-81f2-bed99ca4c4cc.png">

Cette ligne est particuliÃ¨rement longue, assurez-vous que vous avez bien sÃ©lectionnÃ© et copiÃ© l'intÃ©gralitÃ© de la ligne!

### Netlify

Maintenant, si vous n'en avez pas dÃ©jÃ  un, crÃ©ez un [compte Netlify](https://app.netlify.com/signup). Ceci Ã©tant fait, cliquez simplement sur le boutton **New site from Git** situÃ© en haut Ã  droite: 

<img src="https://user-images.githubusercontent.com/300/73697486-85f84a80-4693-11ea-922f-0f134a3e9031.png" />

Donnez l'autorisation Ã  Netlify de se connecter Ã  votre fournisseur d'hÃ©bergement Git, et sÃ©lectionnez le dÃ©pÃ´t de votre application. Laissez les paramÃ¨tres par dÃ©faut et cliquez sur **Deploy site**.

Netlify va alors construire votre application (cliquez sur **Deploying your site** pour prendre connaissance des logs) puis va dire "Site is live",... et rien ne va fonctionner :D Pourquoi? Et pardi, car nous n'avons pas prÃ©cisÃ© oÃ¹ se trouve notre base de donnÃ©es!

Retournez sur la page principale de Netlify, puis rendez-vous dans **Settings**, puis dans **Build & Deploy** > **Environment**. Cliquez sur **Edit variables**. C'est Ã  cet endroit que nous allons coller l'URI de connection que nous avions copiÃ© depuis Heroku (notez que la valeur de **Key** est "DATABASE_URL"). AprÃ¨s avoir collÃ© la valeur, ajoutez `?connection_limit=1` Ã  la fin d'URI. Le format final de l'URI est donc:  `postgres://<user>:<pass>@<url>/<db>?connection_limit=1`.

![Adding ENV var](https://user-images.githubusercontent.com/300/83188236-3e834780-a0e4-11ea-8cfa-790c2e335a92.png)

> Lorsque vous configurez la base de donnÃ©es, vous ajouterez de prÃ©fÃ©rence `?connection_limit=1` Ã  l'URI. Il s'agit d'une [recommandation pour l'utilisation de Prisma](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/deployment#recommended-connection-limit) dans le cadre d'une utilisation Serverless.

Assurez-vous de cliquer sur le boutton **Save**. Maintenant rendez-vous sur l'onglet **Deploys**, ouvrez le champ de sÃ©lection **Trigger deploy** sur la droite et choisissez **Deploy site**: 

![Trigger deploy](https://user-images.githubusercontent.com/300/83187760-835aae80-a0e3-11ea-9733-ff54969bba1f.png)

Avec un peu de chance (et de science!!), tout va fonctionner correctement! Vous pouvez cliquer sur le bouton **Preview** en haut de page avec les logs, ou revenir Ã  la page prÃ©cÃ©dente et cliquer sur l'URL de dÃ©ploiement de votre site situÃ©e en haut de l'Ã©cran:

![Netlify URL](https://user-images.githubusercontent.com/300/83187909-bef57880-a0e3-11ea-97dc-e557248acd3a.png)

Est-ce que Ã§a fonctionne? Si vous voyez "Empty" sous les liens _About_ et _Contact_, c'est que Ã§a marche! Cool! "Empty" signifie simplement que vous n'avez aucun article enregistrÃ© dans votre base de donnÃ©es. Allez simplement sur `/admin/posts` pour en crÃ©er quelques-un, puis revenez sur la page d'accueil de votre application pour les voir s'afficher.

> Si vous regardez le dÃ©ploiement via le bouton **Preview**, remarquez que l'URL contient un hash du dernier commit. Netlify va en crÃ©er un Ã  chaque nouveau push sur la branche `main` mais ne montrera que ce commit. Donc si vous dÃ©ployez Ã  nouveau en executant un refresh, vous ne verrez aucune modification. L'URL de dÃ©ploiement de votre site (celle que vous obtenez depuis la page d'accueil de Netlify) affichera toujours le dernier dÃ©ploiement. Consultez la section suivante "[DÃ©ploiement de Branche](#branch-deploys)" pour plus d'informations.

Si votre dÃ©ploiement n'a pas fonctionnÃ©, consultez le log dans Netlify et voyez si vous comprenez l'erreur qui s'affiche. Si votre dÃ©ploiement s'esst correctement effectuÃ© mais que le site ne s'affiche pas, essayez d'ouvrir les outils de dÃ©veloppement de votre navigateur afin de voir si des erreurs s'affichent. Assurez-vous Ã©galement de bien avoir copiÃ© _en totalitÃ©_ l'URI de connection Postgres depuis Heroku. Si vÃ©ritablement vous ne parvenez pas Ã  trouver d'oÃ¹ vient l'erreur, demandez-donc de l'aide Ã  la [communautÃ© Redwood](https://community.redwoodjs.com).  

### DÃ©ploiements de Branche

Une autre fonctionnalitÃ© bien pratique de Netlify est appelÃ©e _branch deploys_. Lorsque vous crÃ©ez une branche et effectuez un push sur votre dÃ©pÃ´t Git, Netlify va contruire votre application depuis cette branche et vous retourner une URL unique de telle maniÃ¨re que vous puissiez tester vos modifications tout en laissant intacte le dÃ©ploiement effectuÃ© depuis la branche `main`. Une fois que votre branche alternative a Ã©tÃ© _merged_ dans la branche `main`, une nouvelle construction de votre application sera effectuÃ©e en prenant en compte les modifications apportÃ©es par la branche alternative. Pour activer le dÃ©ploiement de branches, allez dans **Settings**>**Continuous Deployment** puis sous la section **Deploy context** cliquez sur **Edit Settings** et modifiez **Branch Deploys** to "All". Vous pouvez Ã©galement activer _Deploy previews_ qui va crÃ©er une prÃ©view pour toute _pull-request_ effectuÃ©e sur votre dÃ©pÃ´t.

![Netlify settings screenshot](https://user-images.githubusercontent.com/30793/90886476-c1016780-e3b2-11ea-851a-3014257484fd.png)

> Vous avez Ã©galement la possibilitÃ© de "vÃ©rouiller" la branche `main` de telle maniÃ¨re que chaque push ne dÃ©clanche pas automatiquement une reconstruction de l'application. Vous devez alors demander Ã  Netlify manuellement de dÃ©ployer la derniÃ¨re version prÃ©sente sur le dÃ©pÃ´t, soit en vous rendant sur le site, soit en utilisant [la CLI Netlify](https://cli.netlify.com/).

### Une remarque Ã  propos des connections aux bases de donnÃ©es

Dans ce didacticiel, vos fonctions lambda vont se connecter directement Ã  la base Postgres. Dans la mesure oÃ¹ Postgres Ã  un nombre limitÃ© de connections concurrentes possibles, son utilisation peut devenir problÃ©matique lorsque le nombre d'utlisateurs croÃ®t Ã©normÃ©ment. La bonne solution est de mettre en place un service de "connection pooling" devant Postgres et y connecter vos fonctions lambda. Pour apprendre comment faire Ã§a, consulter le [guide associÃ©](https://www.redwoodjs.com/docs/connection-pooling). 

## Authentification

"Authentification" est un mot-valise pour tout ce qui se rapporte au fait de s'assurer que l'utilisateur, souvent identifiÃ© Ã  l'aide d'un couple email/mot de passe, est autorisÃ© Ã  accÃ©der Ã  quelque chose. L'authentification peut Ãªtre parfois [dÃ©licate Ã  mettre en oeuvre](https://www.rdegges.com/2017/authentication-still-sucks/) techniquement et vous causer de sÃ©rieux maux de tÃªte. 

Heureusement, Redwood est lÃ  pour vous! L'authentification n'est pas une chose qu'il vous faut Ã©crire en partant de zero, c'est un problÃ¨me identifiÃ© et rÃ©solu qui ne devrait au contraire vous causer que peu de soucis. A ce jour, Redwood s'intÃ©gre avec :

- [Auth0](https://auth0.com/)
- [Netlify Identity](https://docs.netlify.com/visitor-access/identity/)

Puisque nous avons dÃ©jÃ  commecÃ© Ã  dÃ©ployer notre application sur Netlify, nous allons ici dÃ©couvrir ensemble Netlify Identity.

> Il existe deux termes contenant beaucoup de lettres, commenÃ§ant par "A" et finissant par "ation" qu'il bien faut distinguer:
>
> * Authentification (__Authentication__ en anglais)
> * Autorisation (__Authorization__ en anglais)
>
> Voici comment Redwood utilise ces termes:
>
> * **Authentification** se rapporte au fait de savoir dans quelle mesure une personne est bien celle qu'elle prÃ©tend Ãªtre. CelÃ  prend gÃ©nÃ©ralement la forme d'un formulaire de Login avec un email et un mot de passe, ou un fournisseurs OAuth tiers comme Google.
> * **Autorisation** se rapporte au fait de savoir si un utilisateur (qui en gÃ©nÃ©ral s'est dÃ©jÃ  authentifiÃ©) est autorisÃ© Ã  effectuer ou non une action. CelÃ  recouvre en gÃ©nÃ©ral une combinaison de roles et de permissions qui sont Ã©valuÃ©es avant de donner ou refuser l'accÃ¨s Ã  une URL du site.
>
> Cette section du didacticiel se concentre en particulier sur l'**authentification**. Nous travaillons actuellement Ã  inclure un systÃ¨me simple et flexible de rÃ´les. Une fois ceci rÃ©alisÃ©, nous mettrons Ã  jour ce didacticiel! 

### Netlify Identity Setup

En supposant que vous avez complÃ©tÃ© toutes les Ã©tapes prÃ©cÃ©dentes, vous disposez dÃ©jÃ  d'un compte Netlify ainsi que d'une application fonctionelle. Dans ce cas, rendez-vous sur l'onglet **Identity** et cliquez sur le boutton **Enable Identity**:

![Netlify Identity screenshot](https://user-images.githubusercontent.com/300/82271191-f5850380-992b-11ea-8061-cb5f601fa50f.png)

Lorsque l'Ã©cran s'affiche, cliquez sur le boutton **Invite users** et entrez une adresse email. Netlify enverra Ã  cette adresse un lien de confirmation:

![Netlify invite user screenshot](https://user-images.githubusercontent.com/300/82271302-439a0700-992c-11ea-9d6d-004adef3a385.png)

Nous aurons besoin de cet email de confirmation trÃ¨s bientÃ´t, mais pour le moment continuons la mise en place de l'authentification.

### GÃ©nÃ©ration de l'Authentification

Quelques modifications doivent Ãªtre effectuÃ©es sur le code pour mettre en place l'authentification. Fort heureusement, Redwood peut le faire pour nous car un gÃ©nÃ©rateur est prÃ©vu pour Ã§a:

```terminal
yarn rw g auth netlify
```
Cette commande permet d'ajouter un fichier et d'en modifier quelques autres.

> Vous ne remarquez aucun changement?
>
> Afin que celÃ  fonctionne, vous devez utiliser au minimum la version `0.7.0` de Redwood. 
> Le cas Ã©chÃ©ant, [mettez Ã  jour Redwood](/reference/command-line-interface#upgrade) avec `yarn rw upgrade`.

Observez le contenu du fichier `api/src/lib/auth.js` qui vient d'Ãªtre crÃ©Ã© (les commentaires ont Ã©tÃ© supprimÃ© pour plus de clartÃ©):

```javascript
// api/src/lib/auth.js

import { AuthenticationError } from '@redwoodjs/api'

export const getCurrentUser = async (decoded, { token, type }) => {
  return decoded
}

export const requireAuth = () => {
We'll hook up both the web and api sides below to make sure a user is only doing things they're allowed to do.

  if (!context.currentUser) {
    throw new AuthenticationError("You don't have permission to do that.")
  }
}
```

Par dÃ©faut, le systÃ¨me d'authentification va retourner uniquement les donnÃ©es connues par le fournisseur tiers (c'est ce qui se trouve dans l'objet `jwt`). Dans le cas de Netlify Identity, il s'agit d'une adresse email, d'un nom (optionnel), et d'un tableau de roles (optionnel Ã©galement). En gÃ©nÃ©ral, vous disposez de votre propre modÃ©lisation de ce qu'est un utilisateur dans votre base de donnÃ©es. Vous pouvez modifier `getCurrentUser` de faÃ§on Ã  retourner cet utilisateur plutÃ´t que les dÃ©tails enregistrÃ©s par le fournisseur d'authentification. Les commentaires prÃ©sents en haut du fichier vous montrent un exemple permettant de rechercher un utilisateur Ã  partir de l'adresse email rÃ©cupÃ©rÃ©e. Redwood fournit Ã©galement par dÃ©faut la fonction `requireAuth()`, une implÃ©mentation simple pour s'assurer qu'un utilisateur est bien authentifiÃ© afin d'accÃ©der Ã  un service. Le cas Ã©chÃ©ant, une erreur sera lancÃ©e de telle faÃ§on que GraphQL sache quoi faire si un utilisateur non authentifiÃ© essaye de faire quelque chose qu'il ne devrait pas pourvoir effectuer.

Les fichiers qui ont Ã©tÃ© modifÃ©s par le gÃ©nÃ©rateur sont les suivants:

* `web/src/index.js`â€” Entoure le routeur au sein du composant `<AuthProvider>`, ce qui fait que les routes elle-mÃªmes sont soumises Ã  authentification. Cela donne Ã©galement accÃ¨s au "hook" `useAuth()` qui expose quelques fonctions permettant Ã  l'utilisateur de se connecter, se dÃ©connecter, verifier le statut courant, etc.. 
* `api/src/functions/graphql.js`â€” Rend disponible `currentUser` pour la partie API de l'application, de telle faÃ§on que vous puissez verifier si un utilisateur est autorisÃ© ou non Ã  faire quelque chose. Si vous ajoutez une implÃ©mentation Ã  `getCurrentUser()` dans `api/src/lib/auth.js`, alors ce sera ce qui sera retournÃ© par `currentUser`, dans le cas contraire `currentUser` contiendra `null`.

Nous allons connecter les cÃ´tÃ©s Web et API ci-dessous pour nous assurer qu'un utilisateur ne fait que les choses qu'il est autorisÃ© Ã  faire.

### Authentification cÃ´tÃ© API

CommenÃ§ons par verrouiller l'API afin que nous puissions Ãªtre sÃ»rs que seuls les utilisateurs autorisÃ©s peuvent crÃ©er, mettre Ã  jour et supprimer une publication. Ouvrez le service Post et ajoutons une vÃ©rification:

```javascript{4,17,24,32}
// api/src/services/posts/posts.js

import { db } from 'src/lib/db'
import { requireAuth } from 'src/lib/auth'

export const posts = () => {
  return db.post.findMany()
}

export const post = ({ id }) => {
  return db.post.findOne({
    where: { id },
  })
}

export const createPost = ({ input }) => {
  requireAuth()
  return db.post.create({
    data: input,
  })
}

export const updatePost = ({ id, input }) => {
  requireAuth()
  return db.post.update({
    data: input,
    where: { id },
  })
}

export const deletePost = ({ id }) => {
  requireAuth()
  return db.post.delete({
    where: { id },
  })
}

export const Post = {
  user: (_obj, { root }) => db.post.findOne({ where: { id: root.id } }).user(),
}
```

Essayez maintenant de crÃ©er, de modifier ou de supprimer un article de nos pages d'administration. Il ne se passe rien! Devrions-nous afficher une sorte de message d'erreur convivial? Dans ce cas, probablement pas - nous allons verrouiller complÃ¨tement les pages d'administration afin qu'elles ne soient pas accessibles par un navigateur. La seule faÃ§on pour quelqu'un de dÃ©clencher ces erreurs dans l'API est de tenter d'accÃ©der directement au point de terminaison GraphQL, sans passer par notre interface utilisateur. L'API renvoie dÃ©jÃ  un message d'erreur (ouvrez l'inspecteur Web dans votre navigateur et essayez Ã  nouveau de crÃ©er / modifier / supprimer), nous sommes donc couverts.

> Notez que nous mettons les vÃ©rifications d'authentification dans le service et non la vÃ©rification dans l'interface GraphQL (dans les fichiers SDL).
>
> Redwood a crÃ©Ã© le concept de **services** en tant que conteneurs pour votre logique mÃ©tier qui peuvent Ãªtre utilisÃ©s par d'autres parties de votre application en plus de l'API GraphQL. En plaÃ§ant des contrÃ´les d'authentification ici, vous pouvez Ãªtre sÃ»r que tout autre code qui tente de crÃ©er / mettre Ã  jour / supprimer une publication tombera sous les mÃªmes contrÃ´les d'authentification. En fait, Apollo (la bibliothÃ¨que GraphQL utilisÃ©e par Redwood) [est d'accord avec nous](https://www.apollographql.com/docs/apollo-server/security/authentication/#authorization-in-data-models)!

### Authentification cÃ´tÃ© Web

Nous allons maintenant restreindre complÃ¨tement l'accÃ¨s aux pages d'administration, sauf si vous Ãªtes connectÃ©. La premiÃ¨re Ã©tape consistera Ã  indiquer les itinÃ©raires qui nÃ©cessiteront que vous soyez connectÃ©. Pour ce faire, ajouter la balise `<Private>`:

```javascript{3,12,16}
// web/src/Routes.js

import { Router, Route, Private } from '@redwoodjs/router'

const Routes = () => {
  return (
    <Router>
      <Route path="/contact" page={ContactPage} name="contact" />
      <Route path="/about" page={AboutPage} name="about" />
      <Route path="/" page={HomePage} name="home" />
      <Route path="/blog-post/{id:Int}" page={BlogPostPage} name="blogPost" />
      <Private unauthenticated="home">
        <Route path="/admin/posts/new" page={NewPostPage} name="newPost" />
        <Route path="/admin/posts/{id:Int}/edit" page={EditPostPage} name="editPost" />
        <Route path="/admin/posts/{id:Int}" page={PostPage} name="post" />
        <Route path="/admin/posts" page={PostsPage} name="posts" />
      </Private>
      <Route notfound page={NotFoundPage} />
    </Router>
  )
}

export default Routes
```

Entourez les routes que vous voulez protÃ©ger par l'authentification, et ajoutez Ã©ventuellement l'attribut `unauthenticated` qui rÃ©pertorie le nom d'une autre route vers laquelle rediriger si l'utilisateur n'est pas connectÃ©. Dans ce cas, nous reviendrons Ã  la page d'accueil.

Essayez cela dans votre navigateur. Si vous cliquez sur http://localhost:8910/admin/posts, vous devez immÃ©diatement revenir Ã  la page d'accueil.

Il ne reste plus qu'Ã  laisser l'utilisateur se connecter! Si vous avez dÃ©jÃ  crÃ©Ã© une authentification, vous savez que cette partie est gÃ©nÃ©ralement un frein, mais Redwood en fait une gentille promenade au parc. La majeure partie de la plomberie a Ã©tÃ© gÃ©rÃ©e par le gÃ©nÃ©rateur d'authentification, nous pouvons donc nous concentrer sur les parties que l'utilisateur voit rÃ©ellement. Tout d'abord, ajoutons un lien **Login** qui dÃ©clenchera une fenÃªtre modale Ã  partir du [widget Netlify Identity](https://github.com/netlify/netlify-identity-widget). Supposons que nous souhaitons obtenir cela sur toutes les pages publiques, nous allons donc le mettre dans le `BlogLayout`:

```javascript{4,7,22-26}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'
import { useAuth } from '@redwoodjs/auth'

const BlogLayout = ({ children }) => {
  const { logIn } = useAuth()

  return (
    <div>
      <h1>
        <Link to={routes.home()}>Redwood Blog</Link>
      </h1>
      <nav>
        <ul>
          <li>
            <Link to={routes.about()}>About</Link>
          </li>
          <li>
            <Link to={routes.contact()}>Contact</Link>
          </li>
          <li>
            <a href="#" onClick={logIn}>
              Log In
            </a>
          </li>
        </ul>
      </nav>
      <main>{children}</main>
    </div>
  )
}

export default BlogLayout
```

Essayez de cliquer sur le lien Login:

![Netlify Identity Widget modal](https://user-images.githubusercontent.com/300/82387730-aa7ef500-99ec-11ea-9a40-b52b383f99f0.png)

Nous devons informer le widget de l'URL de notre site afin qu'il sache oÃ¹ aller pour obtenir les donnÃ©es des utilisateurs et confirmer qu'ils peuvent se connecter. De retour sur Netlify, vous pouvez l'obtenir Ã  partir de l'onglet **Identity**:

![Netlify site URL](https://user-images.githubusercontent.com/300/82387937-28430080-99ed-11ea-91b7-a4e10f14aa83.png)

Vous avez besoin du protocole et du domaine, pas du reste du chemin. Collez-le dans la fenÃªtre modale et cliquez sur le bouton **Set site's URL**. La fenÃªtre modale devrait se recharger et afficher maintenant une vraie boÃ®te de connection:

![Netlify identity widget login](https://user-images.githubusercontent.com/300/82388116-97205980-99ed-11ea-8fb4-13436ee8e746.png)

Avant de pouvoir nous connecter, vous rappelez-vous cet e-mail de confirmation de Netlify? Allez le trouver et cliquez sur le lien **Accept the invite** . Cela vous amÃ¨nera Ã  votre site en production, oÃ¹ rien ne se passera. Mais si vous regardez l'URL, elle se terminera par quelque chose comme `#invite_token=6gFSXhugtHCXO5Whlc5V`. Copiez-le (y compris le `#`) et ajoutez-le Ã  votre URL localhost: http://localhost:8910/#invite_token=6gFSXhugtHCXO5Whlc5Vg. Appuyez sur EntrÃ©e, puis revenez dans l'URL et appuyez Ã  nouveau sur EntrÃ©e pour qu'il recharge la page. Maintenant, la fenÃªtre modale affichera **Complete your signup** et vous donnera la possibilitÃ© de dÃ©finir votre mot de passe:

![Netlify identity set password](https://user-images.githubusercontent.com/300/82388369-54ab4c80-99ee-11ea-920e-9df10ee0cac2.png)

Une fois que vous faites cela, la fenÃªtre modale devrait se mettre Ã  jour et dire que vous Ãªtes connectÃ©! Ã‡a a marchÃ©! Cliquez sur le X en haut Ã  droite pour fermer la fenÃªtre modale.

> Nous savons que ce workfow d'acceptation des invitations est loin d'Ãªtre idÃ©al. La bonne nouvelle est que, lorsque dÃ©ployez Ã  nouveau votre site avec authentification, les futures invitations fonctionneront automatiquement - le lien ira Ã  la production qui aura dÃ©sormais le code nÃ©cessaire pour lancer le modal et vous permettra d'accepter l'invitation.

Cependant, nous n'avons actuellement aucune indication sur notre site que nous sommes connectÃ©s. Pourquoi ne pas changer le bouton **Log In** en **Log Out** lorsque vous Ãªtes authentifiÃ©:

```javascript{7,23-24}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'
import { useAuth } from '@redwoodjs/auth'

const BlogLayout = ({ children }) => {
  const { logIn, logOut, isAuthenticated } = useAuth()

  return (
    <div>
      <h1>
        <Link to={routes.home()}>Redwood Blog</Link>
      </h1>
      <nav>
        <ul>
          <li>
            <Link to={routes.about()}>About</Link>
          </li>
          <li>
            <Link to={routes.contact()}>Contact</Link>
          </li>
          <li>
            <a href="#" onClick={isAuthenticated ? logOut : logIn}>
              {isAuthenticated ? 'Log Out' : 'Log In'}
            </a>
          </li>
        </ul>
      </nav>
      <main>{children}</main>
    </div>
  )
}

export default BlogLayout
```

`useAuth ()` nous apporte quelques aides supplÃ©mentaires, dans le cas prÃ©sent `isAuthenticated` retournera` true` ou `false` en fonction de votre statut de connexion, et` logOut ()` dÃ©connectera l'utilisateur. Cliquez maintenant sur **Log Out**  pour vous dÃ©connecter et changer le lien en **Log In** sur lequel vous pouvez cliquer pour ouvrir la fenÃªtre modale et vous reconnecter.

Lorsque vous *Ãªtes* connectÃ©, vous devriez pouvoir accÃ©der Ã  nouveau aux pages d'administration: http://localhost:8910/admin/posts

> Si vous commencez Ã  travailler sur une autre application Redwood qui utilise Netlify Identity, vous devrez effacer manuellement votre stockage local, oÃ¹ est stockÃ©e l'URL du site que vous avez entrÃ©e la premiÃ¨re fois que vous avez vu la fenÃªtre modale. Le stockage local est liÃ© Ã  votre domaine et Ã  votre port, qui par dÃ©faut seront les mÃªmes pour toute application Redwood lors du dÃ©veloppement local. Vous pouvez effacer votre stockage local dans Chrome en allant dans l'inspecteur Web, puis dans l'onglet **Application**, puis Ã  gauche, ouvrez **Local Storage** et cliquez sur http://localhost:8910. Vous verrez les clÃ©s stockÃ©es sur la droite et pourrez toutes les supprimer.

Encore un dÃ©tail: montrons l'adresse e-mail de l'utilisateur connectÃ©. Nous pouvons obtenir le `currentUser` par le "hook" `useAuth()`. Il contiendra les donnÃ©es que notre bibliothÃ¨que d'authentification tierce stocke pour l'utilisateur actuellement connectÃ©:

```javascript{7,27}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'
import { useAuth } from '@redwoodjs/auth'

const BlogLayout = ({ children }) => {
  const { logIn, logOut, isAuthenticated, currentUser } = useAuth()

  return (
    <div>
      <h1>
        <Link to={routes.home()}>Redwood Blog</Link>
      </h1>
      <nav>
        <ul>
          <li>
            <Link to={routes.about()}>About</Link>
          </li>
          <li>
            <Link to={routes.contact()}>Contact</Link>
          </li>
          <li>
            <a href="#" onClick={isAuthenticated ? logOut : logIn}>
              {isAuthenticated ? 'Log Out' : 'Log In'}
            </a>
          </li>
          {isAuthenticated && <li>{currentUser.email}</li>}
        </ul>
      </nav>
      <main>{children}</main>
    </div>
  )
}

export default BlogLayout
```

![Logged in email](https://user-images.githubusercontent.com/300/82389433-05b2e680-99f1-11ea-9d01-456cad508c80.png)

> Consultez les paramÃ¨tres d'identitÃ© sur Netlify pour plus d'options, notamment permettre aux utilisateurs de crÃ©er des comptes plutÃ´t que d'avoir Ã  Ãªtre invitÃ©s, ajouter des boutons de connexion tiers pour Bitbucket, GitHub, GitLab et Google, recevoir des webhooks lorsque quelqu'un se connecte, etc... !

Croyez-le ou non, c'est tout! L'authentification avec Redwood est un jeu d'enfant et nous ne faisons que commencer. Attendez-vous Ã  plus de magie bientÃ´t!

> Si vous inspectez le contenu de `currentUser`, vous verrez qu'il contient un tableau appelÃ© `roles`. Sur le tableau de bord Netlify Identity, vous pouvez attribuer Ã  votre utilisateur une collection de rÃ´les, qui ne sont que des chaÃ®nes de caractÃ¨res telles que Â«adminÂ» ou Â«guestÂ». En utilisant cette gamme de rÃ´les, vous *pourriez* crÃ©er un systÃ¨me d'authentification basÃ© sur les rÃ´les trÃ¨s rudimentaire. Ã€ moins que vous n'ayez un besoin urgent de cette simple vÃ©rification de rÃ´le, nous vous recommandons d'attendre la solution Redwood, Ã  venir bientÃ´t!

## Conclusion

Vous l'avez fait! Si vous avez vraiment parcouru tout le tutoriel: fÃ©licitations! Si vous venez de passer Ã  cette page pour essayer d'obtenir des fÃ©licitations gratuites: tss, tss...

Cela reprÃ©sentait potentiellement beaucoup de nouveaux concepts Ã  absorber d'un seul coup, alors ne vous en faÃ®te pas si vous ne retenez pas tout complÃ¨tement. React, GraphQL, Prisma, les fonctions Serverless... tant de choses! MÃªme ceux d'entre nous qui travaillent sur le framework consultent Google plusieurs fois par jour pour comprendre comment faire fonctionner ces Ã©lÃ©ments ensemble.

Comme l'a dit un utilisateur anonyme de Twitter: "Si vous aimez vous sentir Ã  la fois la personne la plus intelligente du monde et la personne la plus stupide de l'histoire en l'espace de 24 heures, la programmation peut Ãªtre un bon choix de carriÃ¨re!"

### Et maintenant?

Vous souhaitez ajouter d'autres fonctionnalitÃ©s Ã  votre application? DÃ©couvrez quelques-un de nos "Cookbook" (livres de recettes) comme [appeler une API tierce](/cookbook/using-a-third-party-api), ou encore [dÃ©ployer une application sans API du tout](/cookbook/disable-api-database). Vous en avez assez de SQLite et souhaitez [installer Postgres localement](/docs/local-postgres-setup)? Nous avons Ã©galement de nombreux [guides](/docs/introduction) pour plus d'informations sur les composants internes de Redwood.

### Feuille de route

Consultez notre [Feuille de route](https://redwoodjs.com/roadmap) pour voir oÃ¹ nous allons et comment nous allons y arriver.
Si vous souhaitez aider, faites-le nous savoir sur le [forum de RedwoodJS] (https://community.redwoodjs.com/) et nous serons heureux de vous accompagner.
Nous voulons atteindre la version `1.0` d'ici la fin de l'annÃ©e. Et avec votre aide, nous pensons que nous pouvons le faire.

### Aidez nous!

Qu'avez-vous pensÃ© de Redwood? Est-ce la prochaine Ã©tape pour les frameworks JS? Que peut-il faire mieux? Nous avons encore beaucoup de choses prÃ©vues. Vous souhaitez nous aider Ã  crÃ©er ces fonctionnalitÃ©s?

- [Ouvrez une pull-request](https://github.com/redwoodjs/redwood/pulls)
- [Redigez un peu de documentation](/docs/introduction)
- [Rejoignez la communautÃ©](https://community.redwoodjs.com)

Merci d'avoir suivi ce didacticiel. Et maintenant, construisez quelque chose d'incroyable!
