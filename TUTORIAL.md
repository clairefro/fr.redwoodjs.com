# Bienvenue chez Redwood

Bienvenue chez Redwood! Si vous ne lâ€™avez pas encore fait, prenez le temps de lire [Redwood README](https://github.com/redwoodjs/redwood/blob/main/README.md) pour en savoir un peu plus sur les origines de Redwood et les problÃ¨mes qu'il entend rÃ©soudre. Redwood assemble plusieurs technologies de faÃ§on inÃ©dite et qui correspond Ã  ce que nous pensons Ãªtre le futur des applications web avec base de donnÃ©es.  

Dans ce didacticiel, nous allons construire un moteur de blog. En rÃ©alitÃ©, un blog nâ€™est probablement pas le candidat idÃ©al pour une application construite avec Redwood: les articles peuvent Ãªtre enregistrÃ©s dans un CMS et gÃ©nÃ©rÃ©es statiquement sous la forme de fichiers HTML servis par un CDN. Ceci Ã©tant, la plupart des dÃ©veloppeurs comprennent intuitivement ce que recouvre ce type dâ€™application, et un blog prÃ©sente toutes les caractÃ©ristiques que nous souhaitons mettre en lumiÃ¨re. Nous avons donc dÃ©cidÃ© d'en construire un malgrÃ© tout.

Peut-Ãªtre souhaitez-vous voir ce didacticiel en vidÃ©o? Câ€™est iciÂ :

<div class="relative pb-9/16">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/tiF9SdM1i7M?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

<div class="relative pb-9/16 mt-4">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/SP5vbsWf5Yg?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

<div class="relative pb-9/16 mt-4">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/eT7iIy0F8Tk?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

<div class="relative pb-9/16 mt-4">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/UpD3HyuZkvY?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

## PrÃ©requis

Ce didacticiel suppose que vous soyez dÃ©jÃ  familier avec quelques concepts fondamentauxÂ :

- [React](https://reactjs.org/)
- [GraphQL](https://graphql.org/)
- [The Jamstack](https://jamstack.org/)

Vous pouvez tout Ã  fait complÃ©ter ce didacticiel sans savoir quoique ce soit sur ces technologies, mais il est possible que vous soyez un peu perdu par certains termes que nous utiliserons sans forcÃ©ment les expliquer au prÃ©alable. D'une faÃ§on gÃ©nÃ©rale, il est toujours utile de savoir oÃ¹ se situe les frontiÃ¨res et pouvoir distinguer par exemple ce qui provient de React de ce qui est ajoutÃ© par Redwood. 

### Node.js et Yarn

Pendant lâ€™installation, RedwoodJS commence par verifier si votre systÃ¨me possÃ¨de les versions requises de Node et YarnÂ :

- node: ">=12"
- yarn: ">=1.15"

ğŸ‘‰ **Important:** Si votre systÃ¨me ne repond pas Ã  ces prÃ©requis, _lâ€™installation se soldera par une ERREUR._ VÃ©rifiez en exÃ©cutant les commandes suivantes dans un terminal:

```
node --version
yarn --version
```
ProcÃ©dez aux mises Ã  jour le cas Ã©chÃ©ant, puis relancez lâ€™installation de RedwoodJS lorsque vous Ãªtes prÃªtâ€¯!


> **Installer Node et Yarn**
>
> Il y a diffÃ©rentes faÃ§ons dâ€™installer Node.js et Yarn. Si vous procÃ©dez Ã  leur installation pour la premiÃ¨re fois, nous vous recommandons de suivre les points suivantsÂ :
>
> **Yarn**
>
> - Nous recommandons de suivre les instructions fournies sur [Yarnpkg.com](https://classic.yarnpkg.com/en/docs/install/).
>
> **Node.js**
>
> - Pour les utilisateurs de **Linux** et **Mac**, `nvm` est un excellent outil pour gÃ©rer plusieurs versions de Node sur un mÃªme systÃ¨me. Il demande un petit effort Ã  mettre en place. Dans les deux cas, utiliser la version la plus rÃ©cente de [Nodejs.org](https://nodejs.org/en/) fonctionne trÃ¨s bien.
>   - Pour les utilisateurs de **Mac**, si vous avez dejÃ  installÃ© Homebrew, vous pouvez lâ€™utiliser pour [installer `nvm`](https://formulae.brew.sh/formula/nvm). Dans le cas contraire, suivez les [instructions d'installation pour `nvm`](https://github.com/nvm-sh/nvm#installing-and-updating).
>   - Pour les utilisateurs de **Linux**, vous pouvez suivre les [instructions d'installation pour `nvm`](https://github.com/nvm-sh/nvm#installing-and-updating).
> - Nous recommandons aux utilisateurs de **Windows** de visiter [Nodejs.org](https://nodejs.org/en/) pour savoir comment procÃ©der.
>
> Si vous Ãªtes un peu perdu au moment de choisir quelle version de Node utiliser, nous vous recommandons la plus rÃ©cente LTS avec un numÃ©ro de version pair, actuellement il s'agit de la v12.

## Installation & DÃ©marrage du dÃ©veloppement

Nous utiliserons yarn ([yarn](https://yarnpkg.com/en/docs/install) est un prÃ©-requis) pour crÃ©er la structure de base pour notre applicationÂ :

    yarn create redwood-app ./redwoodblog

Vous obtenez ainsi un nouveau rÃ©pertoire `redwoodblog` contenant plusieurs sous-rÃ©pertoires et fichiers. DÃ©placez-vous dans ce rÃ©pertoire, puis lancez le serveur de dÃ©veloppementÂ :

    cd redwoodblog
    yarn redwood dev

Votre navigateur web devrait se lancer automatiquement et ouvrir `http://localhost:8910` laissant apparaÃ®tre la page dâ€™accueil de Redwood. 

![Redwood Welcome Page](https://user-images.githubusercontent.com/300/73012647-97a43d00-3dcb-11ea-8554-42df29c36e4a.png)

> MÃ©moriser le numÃ©ro de port est trÃ¨s simple, comptez simplement: 8-9-10!

### Premier Commit

Maintenant que nous avons le squelette de notre application Redwood, c'est le bon moment pour enregistrer notre travail avec un premier commit... au cas oÃ¹.

    git init
    git add .
    git commit -m 'Premier commit'

## Structure d'une application Redwood

Examinons maintenant les fichiers et rÃ©pertoires qui ont Ã©tÃ© crÃ©Ã©s pour nous (laissons de cÃ´tÃ© les fichiers de configuration sur lesquels nous reviendrons plus tard)

```terminal
â”œâ”€â”€ api
â”‚   â”œâ”€â”€ prisma
â”‚   â”‚   â”œâ”€â”€ schema.prisma
â”‚   â”‚   â””â”€â”€ seeds.js
â”‚   â””â”€â”€ src
â”‚       â”œâ”€â”€ functions
â”‚       â”‚   â””â”€â”€ graphql.js
â”‚       â”œâ”€â”€ graphql
â”‚       â”œâ”€â”€ lib
â”‚       â”‚   â””â”€â”€ db.js
â”‚       â””â”€â”€ services
â””â”€â”€ web
    â”œâ”€â”€ public
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ favicon.png
    â”‚   â””â”€â”€ robots.txt
    â””â”€â”€ src
        â”œâ”€â”€ Routes.js
        â”œâ”€â”€ components
        â”œâ”€â”€ index.css
        â”œâ”€â”€ index.html
        â”œâ”€â”€ index.js
        â”œâ”€â”€ layouts
        â””â”€â”€ pages
            â”œâ”€â”€ FatalErrorPage
            â”‚   â””â”€â”€ FatalErrorPage.js
            â””â”€â”€ NotFoundPage
                â””â”€â”€ NotFoundPage.js
```
Au premier niveau nous avons deux rÃ©pertoires, `api` et `web`. Redwood sÃ©pare le backend (`api`) et le frontend (`web`) au sein du projet. ([Yarn qualifie cette sÃ©paration de "workspaces"](https://yarnpkg.com/lang/en/docs/workspaces/). Avec Redwood, on fait plutÃ´t rÃ©fÃ©rence aux "cÃ´tÃ©s" web et api de l'application). Ainsi, lorsque plus tard vous serez amenÃ© Ã  ajouter des packages, il vous faudra prÃ©ciser dans quel cÃ´tÃ© ils doivent aller. Par exemple, (inutile d'exÃ©cuter ces commandes):

    yarn workspace web add marked
    yarn workspace api add better-fs

### Le RÃ©pertoire /api

A l'intÃ©rieur du rÃ©pertoire `api` se trouve deux sous-rÃ©pertoires :

- `prisma` contient du code d'infratructure relatif Ã  la base de donnÃ©e

  - `schema.prisma` contient le schÃ©ma de la base de donnÃ©es (ses tables et ses colonnes)
  - `seeds.js` est utilisÃ© pour initialiser la base de donnÃ©es avec les donnÃ©es de base nÃ©cessaire Ã  votre application (utilisateur admin, configuration diverses..).

  Lorsque nous aurons crÃ©Ã© notre premiÃ¨re table dans la base de donnÃ©es, nous trouverons Ã©galement Ã  cet endroit une base de donnÃ©es SQLite sous la forme dâ€™un fichier `dev.db`, ainsi quâ€™un rÃ©pertoire `migrations` contenant des captures successives du schÃ©ma au fil de son Ã©volution.

- `src` contient l'ensemble du code cÃ´tÃ© backend. `api/src` contient quatre rÃ©pertoires supplÃ©mentairesÂ :
  - `functions` contiendra toutes les [fonctions lambda](https://docs.netlify.com/functions/overview/) utilisÃ©es par votre application en plus du fichier `graphql.js` gÃ©nÃ©rÃ© automatiquement par Redwood. Ce dernier fichier est requis pour utiliser une API GraphQL.
  - `graphql` contient votre schÃ©ma GraphQL Ã©crit au format SDL (Schema Definition Language). Les fichiers SDL se terminent par `.sdl.js`.
  - `lib` contient un seul fichier, `db.js`, qui instancie le client Prisma utilisÃ© pour dialoguer avec la base de donnÃ©es. Vous pouvez parfaitement personnaliser ce fichier en ajoutant des options supplÃ©mentaires. Vous pouvez utiliser ce rÃ©pertoire pour tout code relatif au cÃ´tÃ© API de votre application qui ne trouverai pas sa place dans `functions` ou `services`.
  - `services` contient la logique mÃ©tier de votre application. Lorsque vous effectuez une requÃªte ou une mutation de donnÃ©es via GraphQL, ce code se trouve ici dans un format rÃ©utilisable depuis dâ€™autres endroits de votre application.

Et nous en avons terminÃ© avec la partie backend.

### Le rÃ©pertoire /web

- `src` contient plusieurs sous-rÃ©pertoiresÂ :
  - `components` contient vos composants React traditionnels ainsi que les _Cells_ introduites par Redwood (nous y reviendrons bientÃ´t en dÃ©tail).
  - `layouts` contient du code HTML sous forme de composants qui viennent entourer le contenu de votre application et sont partagÃ©s par les diffÃ©rentes _Pages_.
  - `pages` contient des composants souvent insÃ©rÃ©s dans les _Layouts_ et qui constituent les points d'entrÃ©es de votre application pour une URL donnÃ©e (une URL comme `/articles/hello-world` correspondra ainsi Ã  une page tandis que `/contact-us` correspondra Ã  une autre page). Chaque nouvelle application comprend deux pages par dÃ©fautÂ :
    - `NotFoundPage.js` qui est utilisÃ©e lorsquâ€™aucune route nâ€™est trouvÃ©e par le routeur (voir `Routes.js` plus bas).
    - `FatalErrorPage.js` qui est utilisÃ©e lorsquâ€™une erreur survient, quâ€™elle nâ€™a pas Ã©tÃ© gÃ©rÃ©e, et quâ€™il nâ€™est pas possible de poursuivre plus avant sans faire exploser lâ€™application (en gÃ©nÃ©ral il sâ€™agit dâ€™une page blanche).
- `public` contient des ressources non utilisÃ©es par vos composants React (En bout de chaÃ®ne, ces ressources seront copiÃ©es sans Ãªtre modifiÃ©es dans le rÃ©pertoire racine de lâ€™application finale):
  - `favicon.png` est lâ€™icÃ´ne utilisÃ©e par les onglets des navigateurs lorsquâ€™une page est ouverte (par dÃ©faut il sâ€™agit du logo RedwoodJS).
  - `robots.txt` est utilisÃ© pour controller ce que les moteurs de recherche sont [autorisÃ© Ã  indexer](https://www.robotstxt.org/robotstxt.html).
  - `README.md` explique comment, et quand, utiliser le rÃ©pertoire `public` pour vos ressources statiques. Il mentionne Ã©galement les bonnes mÃ©thodes pour importer des ressources Ã  l'intÃ©rieur des composants via Webpack. Vous pouvez Ã©galement lire Ã  ce sujet ce [fichier README.md sur GitHub](https://github.com/redwoodjs/create-redwood-app/tree/main/web/public).
- `index.css` est l'endroit par dÃ©faut oÃ¹ placer vos rÃ¨gles CSS. Il existe cependant dâ€™autres possibilitÃ©s avancÃ©es.
- `index.html` est le point dâ€™entrÃ©e React standard de votre application.
- `index.js` contient le code de dÃ©marrage pour une application Redwood.
- `Routes.js` contient les dÃ©finitions des routes de lâ€™application afin de faire correspondre chaque URL Ã  une _Page_.

## Notre PremiÃ¨re Page

Donnons Ã  nos utilisateurs quelque chose de plus Ã  contempler que la page d'accueil de Redwood. Utilisons la commande `redwood` pour crÃ©er une premiÃ¨re pageÂ :

    yarn redwood generate page home /

Cette commande fait les choses suivantesÂ :

- CrÃ©ation de `web/src/pages/HomePage/HomePage.js`. Redwood prend le nom spÃ©cifiÃ© comme premier argument, le met en majuscules et le suffixe avec "Page" pour construire votre nouveau composant de type Page.
- CrÃ©ation dâ€™un fichier de test du composant `web/src/pages/HomePage/HomePage.test.js` avec un simple test dâ€™exemple Ã  lâ€™intÃ©rieur. Vous Ã©crivez _toujours_ les tests de vos composants, _nâ€™est-ce pasâ€¯??_
- CrÃ©ation dâ€™un fichier Storybook `web/src/pages/HomePage/HomePage.stories.js`. Storybook est un outil formidable pour dÃ©velopper efficacement et organiser vos composants. Si vous souhaitez en savoir plus jetez un oeuil Ã  ce [sujet sur le forum Redwood](https://community.redwoodjs.com/t/how-to-use-the-new-storybook-integration-in-v0-13-0/873) pour apprendre comment lâ€™utiliser.
- Ajout dâ€™une `<Route>` dans `web/src/Routes.js` qui fait correspondre le chemin `/` Ã  la nouvelle page _HomePage_.

> **Import automatique des pages dans le fichier Routes**
>
> Si vous regardez dans Routes, vous constaterez mention d'un composant, `HomePage`, qui n'est prÃ©sent nulle part ailleurs. Redwood importe automatiquement toutes les pages dans le fichier Routes puisque nous aurons besoin de toutes les rÃ©fÃ©rencer de toute faÃ§on. Cela permet de s'Ã©pargner un `import` massif qui viendrait encombrer le fichier Routes.

En rÃ©alitÃ©, cette page est dÃ©jÃ  active (et votre navigateur lâ€™a rechargÃ©e pour vous)Â :

![Default HomePage render](https://user-images.githubusercontent.com/300/76237559-b760ba80-61eb-11ea-9a77-b5006b03031f.png)

Dâ€™accord, Ã§a ne flatte pas encore la rÃ©tine mais câ€™est un dÃ©but! Ouvrez cette page dans votre Ã©diteur, modifiez un peu le texte et sauvegardez. Votre navigateur devrait recharger la page avec vos modifications.

### Routing

Ouvrez `web/src/Routes.js` et observez la route qui vient dâ€™Ãªtre crÃ©Ã©eÂ :

```html
<Route path="/" page={HomePage} name="home" />
```

Essayez de modifier cette route de la faÃ§on suivante:

```html
<Route path="/hello" page={HomePage} name="home" />
```

DÃ¨s que vous ajoutez votre premiÃ¨re route, la page d'accueil par dÃ©faut de Redwood disparaÃ®t. DÃ©sormais, lorsqu'aucune route ne peut Ãªtre trouvÃ©e pour l'URL demandÃ©e, Redwood va retourner la page `NotFoundPage`. Modifiez l'URL de votre navigateur pour ouvrir `http://localhost:8910/hello`, vous devriez voir de nouveau le contenu de `HomePage.js`.

Modifiez Ã  nouveau la route pour revenir Ã  son Ã©tat initial `/` avant de continuer. 

## Une Seconde Page et un Lien

Ajoutons donc une page "About" Ã  notre blog de maniÃ¨re Ã  ce que personne n'ignore qui se trouve derriÃ¨re cette application exceptionnelle. Nous allons crÃ©er une nouvelle page en utilisant `redwood`:

    yarn redwood generate page about

Remarquez que nous n'avons pas spÃ©cifiÃ© de chemin cette fois-ci, uniquement le nom de la page. En effet, si vous ne le prÃ©cisez pas, la commande `redwood generate page` crÃ©era une `Route` en lui donnant pour chemin le nom de la page prÃ©fixÃ© par un slash `/`. Dans le cas prÃ©sent, ce sera donc `/about`. 

> **Fragmenter le code pour chaque page**
>
> Au fur et Ã  mesure que vous ajoutez des pages Ã  votre application, vous pouvez lÃ©gitimement vous inquiÃ©ter du fait que le navigateur va devoir tÃ©lÃ©charger un volume initial de donnÃ©es toujours croissant. Soyez rassurÃ©! Redwood va automatiquement fragmenter le code pour chaque page de telle faÃ§on que le chargement soit toujours extrÃªmement vÃ©loce. Vous pouvez donc crÃ©er autant de pages que vous le souhaitez sans vous inquiÃ©ter outre mesure de la taille finale du bundle webpack. Si, dans le cas contraire, vous souhaitez que certaines pages soient spÃ©cifiquement intÃ©grÃ©es dans le bundle principal, il vous est possible de personaliser cette fonctionalitÃ©.

`http://localhost:8910/about` devrait maintenant pointer sur votre nouvelle page. Bien entendu, absolument personne ne va trouver cette page de votre blog en modifiant manuellement l'URL! Ajoutons donc un lien depuis la page d'accueil vers la page About, et vice-versa. Nous commencerons par crÃ©er un simple header et une barre de navigation dans `HomePage.js`:

```javascript{3,7-19}
// web/src/pages/HomePage/HomePage.js

import { Link, routes } from '@redwoodjs/router'

const HomePage = () => {
  return (
    <>
      <header>
        <h1>Redwood Blog</h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.about()}>A Propos</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>Home</main>
    </>
  )
}

export default HomePage
```

Remarquons ici plusieurs points :

- Redwood adore les "[Function Components](https://www.robinwieruch.de/react-function-component)". Nous ferons un usage frÃ©quent des "[React Hooks](https://reactjs.org/docs/hooks-intro.html)" au fil de l'Ã©laboration de notre blog, et ces derniers ne sont actifs que dans les "function components". Vous Ãªtes libres d'utiliser des "class components", mais nous vous recommandons de les Ã©viter sauf cas particulier.
- Les balises Redwood `<Link>`, dans leur usage le plus simple, prennent un seul attribut `to`. Cet attribut `to` appelle une "_named route function_" de faÃ§on Ã  gÃ©nÃ©rer l'URL correcte. Cette fonction possÃ¨de le mÃªme nom que l'attribut `name` prÃ©sent sur la `<Route>`:

  `<Route path="/about" page={AboutPage} name="about" />`

  Si vous n'aimez pas le nom que la commande `redwood generate` utilise pour votre route, vous pouvez parfaitement le changer dans le fichier `Routes.js`! Les routes nommÃ©es sont extrÃªmement utiles car, si vous dÃ©sirez modifiez le chemin associÃ© avec une route, il vous suffit de le modifier dans le fichier `Routes.js` et immÃ©diatement tous les liens qui utilisent cette route pointerons au bon endroit. Vous pouvez Ã©galement passer directement une chaÃ®ne de caractÃ¨res Ã  l'attribut `to`, mais alors vous ne bÃ©nÃ©ficiez plus de ce mÃ©canisme bien utile. 

### Retour Ã  la maison

Une fois sur la page "About", nous n'avons aucun moyen de revenir en arriÃ¨re. Pour y remÃ©dier, ajoutons Ã©galement un lien Ã  cet endroit:

```javascript{3,7-25}
// web/src/pages/AboutPage/AboutPage.js

import { Link, routes } from '@redwoodjs/router'

const AboutPage = () => {
  return (
    <>
      <header>
        <h1>Redwood Blog</h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>
        <p>
          Ce site est crÃ©Ã© avec pour seule intention de dÃ©montrer la puissance crÃ©ative de Redwood! Oui, c'est trÃ¨s 
          impressionant :D
        </p>
        <Link to={routes.home()}>Retour Ã  la page d'accueil</Link>
      </main>
    </>
  )
}

export default AboutPage
```

Bien! Affichons cette page dans le navigateur and vÃ©rifions que nous pouvons aller et venir entre les diffÃ©rentes pages.

En tant que dÃ©veloppeur de classe cosmique, vous avez probablement repÃ©rÃ© ce copier-coller un peu lourd du `<header>`. Nous aussi. C'est la raison pour laquelle Redwood dispose d'un petite chose bien pratique appelÃ© "_Layout_"."

## Layouts

Une faÃ§on de rÃ©soudre la duplication du `<header>` aurait pu Ãªtre de crÃ©er un composant `<Header>` et l'inclure Ã  la fois dans `HomePage` et `AboutPage`. C'est valide! Mais il y a beaucoup mieux... Dans l'idÃ©al, votre code ne devrait comporter qu'une seule et unique balise `<header>`.

Lorsque vous regardez Ã  ces deux pages, quelle est leur raison d'Ãªtre principale? Toutes deux ont un peu de contenu Ã  afficher. Toutes deux ne devraient pas avoir Ã  connaÃ®tre ce qui vient avant ce contenu (comme un `<header>`), ou aprÃ¨s ce mÃªme contenu (comme un `<footer>`). C'est exactement ce que font les "Layouts": ils entourent une page dans un composant qui va ensuite afficher Ã  l'intÃ©rieur le contenu de la page:

<img src="https://user-images.githubusercontent.com/300/70486228-dc874500-1aa5-11ea-81d2-eab69eb96ec0.png" alt="Diagramme de structure des Layouts" width="300">

Utilisons Redwood pour gÃ©nÃ©rer un layout contenant ce `<header>` :

    yarn redwood g layout blog

> **raccourci `generate`**
>
> DÃ©sormais nous utiliserons le raccourci `g` Ã  la place de `generate`

Ce faisant, nous avons crÃ©Ã© le fichier `web/src/layouts/BlogLayout/BlogLayout.js` et un son fichier de test associÃ©. Nous appellerons ce dernier le "blog" layout car nous aurons certainement d'autres layout plus tard (un layout "admin" par exemple).

Supprimez ce `<header>` de `HomePage` et `AboutPage` et copier son contenu Ã  l'intÃ©rieur du layout. Supprimons Ã©galement le doublon de la balise `<main>` par la mÃªme occasion.

```javascript{3,7-19}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'

const BlogLayout = ({ children }) => {
  return (
    <>
      <header>
        <h1>Redwood Blog</h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>{children}</main>
    </>
  )
}

export default BlogLayout
```

`children` est l'endroit oÃ¹ la magie opÃ¨re! Toute page passÃ©e en argument Ã  un layout s'affiche lÃ . Pour en revenir Ã  `HomePage` et `AboutPage`, en les entourant simplement au sein du `<BlogLayout>`, nos deux pages ne font dÃ©sormais que ce qu'elles sont supposÃ©es faire: afficher leur contenu. Nous pouvons maintenant supprimer les imports de `Link`et `Route` puisqu'ils figurent Ã©galement dans le Layout.

```javascript{3,6}
// web/src/pages/HomePage/HomePage.js

import BlogLayout from 'src/layouts/BlogLayout'

const HomePage = () => {
  return <BlogLayout>Home</BlogLayout>
}

export default HomePage
```

```javascript{4,8-14}
// web/src/pages/AboutPage/AboutPage.js

import { Link, routes } from '@redwoodjs/router'
import BlogLayout from 'src/layouts/BlogLayout'

const AboutPage = () => {
  return (
    <BlogLayout>
        <p>
          Ce site est crÃ©Ã© avec pour seule intention de dÃ©montrer la puissance crÃ©ative de Redwood! Oui, c'est trÃ¨s 
          impressionant :D
        </p>
      <Link to={routes.home()}>Return home</Link>
    </BlogLayout>
  )
}

export default AboutPage
```

> **L'alias `src`**
>
> Remarquez que l'import utilise `src/layouts/BlogLayout` et non `../src/layouts/BlogLayout` ou `./src/layouts/BlogLayout`. Pouvoir se contenter d'ajouter uniquement `src` est un petit apport bien pratique de Redwood: `src` est un alias pour le chemin du rÃ©pertoire `src` du workspace courant. En d'autres termes, lorsque vous travaillez dans `web`, `src` pointe vers `web/src`. Et lorsque vous travaillez dans `api` il pointe vers `api/src`. 

Revenez donc dans votre navigateur, et vous devriez alors voir...... rien de nouveau. Et c'est trÃ¨s bien! Votre layout fonctionne parfaitement.

> **Pourquoi certaines choses sont nommÃ©es d'une certaine faÃ§on?**
>
> Il est possible que vous ayez remarquÃ© quelques rÃ©petitions dans le nom des fichiers utilisÃ©s par Redwood. Ainsi les pages se trouvent dans un rÃ©pertoire appelÃ© `/pages`, et contiennent de nouveau `Page` dans leur nom. Idem pour les Layouts. Pourquoi de choix?
>
> Lorsque vous avez des dizaines de fichiers ouverts dans votre Ã©diteur de code, il est facile de se perdre. C'est d'autant plus le cas lorsque vous avez des fichiers aux noms similaires dans des rÃ©pertoires diffÃ©rents. A l'usage, il nous est apparut que cette petite rÃ©petition dans les noms Ã©tait au final bien pratique lorsqu'il s'agit de repÃ©rer un fichier prÃ©cis parmi tous les onglets ouverts..
>
> Le plugin [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) peut Ã©galement vous aider Ã  distinguer les fichiers entre eux.
>
> <img src="https://user-images.githubusercontent.com/300/73025189-f970a100-3de3-11ea-9285-15c1116eb59a.png" width="400">

### Retour Ã  la Maison, encore une fois

Ajoutons encore un autre `<Link>` de faÃ§on Ã  ce que le titre et le logo pointent vers la page d'accueil:

```javascript{9-11}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'

const BlogLayout = ({ children }) => {
  return (
    <>
      <header>
        <h1>
          <Link to={routes.home()}>Redwood Blog</Link>
        </h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>{children}</main>
    </>
  )
}

export default BlogLayout
```

Enfin nous pouvons Ã©liminer de la page About le lien "Retour Ã  la page d'accueil" devenu superflu (ainsi que les imports `Link` et `routes` associÃ©s).

```javascript
// web/src/pages/AboutPage/AboutPage.js

import BlogLayout from 'src/layouts/BlogLayout'

const AboutPage = () => {
  return (
    <BlogLayout>
      <p>
        Ce site est crÃ©Ã© avec pour seule intention de dÃ©montrer la puissance crÃ©ative de Redwood! Oui, c'est trÃ¨s 
        impressionant :D
      </p>
    </BlogLayout>
  )
}

export default AboutPage
```

## Devenir Dynamique

La seconde partie du didacticiel est disponible en video ici:

<div class="relative pb-9/16">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/SP5vbsWf5Yg?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

Ces deux pages sont plutÃ´t sympas, mais un blog sans article c'est tout de mÃªme un peu lÃ©ger! Travaillons sur ce point Ã  prÃ©sent.

Pour les besoins de ce didacticiel, nous allons rÃ©cupÃ©rer nos articles depuis la base de donnÃ©es. Puisque les bases de donnÃ©es relationelles sont encore aujourd'hui au coeur de beaucoup d'applications complexes (ou moins complexes d'ailleurs), nous avons fait en sorte de rÃ©server un traitement de premiÃ¨re classe aux accÃ¨s SQL. Dans une application Redwood, tout part du schÃ©ma. 

### CrÃ©er le schÃ©ma de la base de donnÃ©es

Nous devons identifier quelles donnÃ©es seront nÃ©cessaires pour un article. Plus tard nous ajouterons d'autres Ã©lÃ©ments, mais pour commencer nous avons besoin de ceci:

- `Ã¬d` l'identifiant unique pour un article (chaque table de notre base de donnÃ©es aura Ã©galement un identifiant tel que celui-ci)
- `title` le titre de l'article
- `body` le contenu de l'article
- `createdAt` un 'timestamp' correspondant au moment oÃ¹ l'article est enregistrÃ© dans la base de donnÃ©es

Nous utilisons [Prisma Client JS](https://github.com/prisma/prisma-client-js) pour parler vac la base de donnÃ©es. Prisma possÃ¨de aun autre librairie, appellÃ©e [Migrate](https://github.com/prisma/migrate), qui nous permet de mettre Ã  jour le schÃ©ma de la base de donnÃ©es en capturant chaque changement successif. Chacun de ces changement est appelÃ© _migration_, et cette librairie Migrate en crÃ©Ã© un nouveau Ã  chaque modification du schÃ©ma.  

Tout d'abord, dÃ©finissons la structure d'un article de notre blog dans la base de donnÃ©es. Ouvrez `api/prisma/schema.prisma` et ajoutez la dÃ©finition de la table `Post` (supprimez au passage tous les modÃ¨les prÃ©sents par dÃ©faut dans ce fichier). Une fois terminÃ©, le fichier se prÃ©sente ainsi: 

```plaintext{13-18}
// api/prisma/schema.prisma

datasource DS {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = "native"
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  body      String
  createdAt DateTime @default(now())
}
```

Cette sÃ©rie d'instructions signifie que nous voulons crÃ©er une table `Post` avec les Ã©lÃ©ments suivants:

- Un champ `id` de type `Int`, nous prÃ©cisions Ã  Prisma que cette colonne constitue un identifiant `@id` (de faÃ§on Ã  pouvoir crÃ©er des relations avec d'autres tables) et que la valeur par `@default` correspond Ã  la fonction Prisma `autoincrement()` impliquant que la base de donnÃ©es insÃ¨rera une nouvelle valeur automatiquement lorsqu'un enregistrement est crÃ©Ã©.
- Un champ `title` de type `String`
- Un champ `body` Ã©galement de type `String`
- Un champ `createdAt` de type `DateTime` avec une valeur par `@default` Ã©gale Ã  `now()` pour chaque nouvel enregistrement (ainsi nous n'avons pas Ã  nous en charger dans l'application, la base de donnÃ©es le fera pour nous)

> **Identifiant de type Integer vs. identifiant de type String**
>
> Pour le didacticiel, nous resterons simple et utiliserons un identifiant de type Integer. Ceci Ã©tant, une application plus Ã©voluÃ©e pourra utiliser un identifiant de type CUID ou UUID. Tous deux sont pris en charge par Prisma. Dans ce cas, vous utiliseriez un champ de type `String` au lieu de `Int`, et `cuid()` ou `uuid()` au lieu de `autoincrement()`:
>
> `id String @id @default(cuid())`
>
> Notez que l'utilisation d'un identifiant de type Integer permet d'obtenir des url plus simples comme https://redwoodblog.com/posts/123 instead of https://redwoodblog.com/posts/eebb026c-b661-42fe-93bf-f1a373421a13. 
>
> Allez voir la [documentation officielle de Prisma](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/data-model#defining-an-id-field) pour plus de dÃ©tails sur les champs identifiants.

### Migrations

Bon, la crÃ©ation du schÃ©ma : c'est fait! Maintenant ce que nous vonlons c'est capturer son Ã©tat pour en faire une _migration_:

    yarn redwood db save create posts

Ce faisant, vous venez de nommer votre premiÃ¨re migration "create posts". Redwood ne tient pas compte de ce nom, mais il est recommandÃ© de choisir un nom significatif pour les autres dÃ©veloppeurs de votre Ã©quipe.

Une fois la commande exÃ©cutÃ©e, vous pourrez constater la crÃ©ation d'un nouveau sous-rÃ©pertoire dans `api/prisma/migrations` avec un _timestamp_ et le nom que vous avez donnÃ© votre migration. Ce sous-rÃ©pertoire contient quelques fichiers: une capture du schÃ©ma de la base dans `schema.prisma`, ainsi que la suite de directives que Prima utilise pour effectuer les modifications dans `steps.json`).

Nous allons maintenant appliquer cette migration avec cette commande:

    yarn rw db up

> **RaccourÃ§i `redwood`**
>
> DÃ©sormais, nous utiliserons dans nos commandes la forme courte `rw` Ã  la place de `redwood`.

L'exÃ©cution de cette commande permet Ã  Prisma d'appliquer les changements sur la base de donnÃ©es, en l'espÃ¨ce la crÃ©ation d'une nouvelle table `Post` avec les champs dÃ©finis plus haut.

### CrÃ©er une Interface d'Ã‰dition d'un Article

Nous n'avons pas encore dÃ©cidÃ© du look de notre site, mais ne serait-il pas extra si nous pouvions commencer Ã  manipuler nos articles de blog, commencer Ã  crÃ©er quelques pages rapidement le temps que l'Ã©quipe chargÃ©e du design rende sa copie? Heureusement pour nous, "Incroyable" est le petit nom de Redwood :)

GÃ©nÃ©rons tout ce sont nous avons besoin pour rÃ©aliser un CRUD (Create, Retrieve, Update, Delete) (CrÃ©er, RÃ©cupÃ©rer, Mettre Ã  jour, Supprimer) sur nos articles. Redwood a justement un generateur spÃ©cialement fait pour Ã§a :

    yarn rw g scaffold post

Ouvrons la page `http://localhost:8910/posts` et constatons le rÃ©sultat:

<img src="https://user-images.githubusercontent.com/300/73027952-53c03080-3de9-11ea-8f5b-d62a3676bbef.png" />

Humm.. Ã§a n'est pas beaucoup plus que ce que nous avions obtenu losque nous avions crÃ©Ã© notre premiÃ¨re page. Que se passe-t-il lorsque nous cliquons sur le bouton "New Post" (Nouvel Article) ?

<img src="https://user-images.githubusercontent.com/300/73028004-72262c00-3de9-11ea-8924-66d1cc1fceb6.png" />

Ah, maintenant on commence Ã  parler sÃ©rieusement! Remplissez donc les champs _title_ (titre) et _body_ (contenu), puis cliquez sur "Save" pour enregistrer.

<img src="https://user-images.githubusercontent.com/300/73028757-08a71d00-3deb-11ea-8813-046c8479b439.png" />

Venons-nous bien de crÃ©er un nouvel article? Exactement! Essayez-donc d'en crÃ©er d'autres.

<img src="https://user-images.githubusercontent.com/300/73028839-312f1700-3deb-11ea-8e83-0012a3cf689d.png" />

Et maintenant, que se passe-t-il lorsqu'on clique sur "Edit" (Ã©diter) pour l'un de ces articles?

<img src="https://user-images.githubusercontent.com/300/73031307-9802ff00-3df0-11ea-9dc1-ea9af8f21890.png" />

D'accord, et en cliquant sur le bouton "Delete" (supprimer)?

<img src="https://user-images.githubusercontent.com/300/73031339-aea95600-3df0-11ea-9d58-475d9ef43988.png" />

Oui c'est bien Ã§a, en une seule commande, Redwood Ã  crÃ©Ã© l'ensemble des pages, composants et services nÃ©cessaires aux opÃ©rations usuelles de manipulation des articles. Pas mÃªme besoin d'ouvrir le gestionnaire de base de donnÃ©es. Redwood appelle ceci des _scaffolds_. Pas mal, non?

Voici dans le dÃ©tail ce qui arrive lorsqu'on execute la commande `yarn rw g scaffold post` : 

- Ajout d'un fichier _SDL_ pour dÃ©finir quelques requÃªtes et mutations GraphQL dans `api/src/graphql/posts.sdl.js` 
- Ajout d'un fichier _service_ `api/src/services/posts/posts.js` qui permet au client Javascript Prisma de manipuler la base de donnÃ©es
- Ajout de quelques _pages_ dans `web/src/pages`:  
  - `EditPostPage` pour Ã©diter un article
  - `NewPostPage` pour crÃ©er un nouvel article
  - `PostPage` pour montrer les dÃ©tails d'un article
  - `PostsPage` pour lister tous les articles
- Ajout de _routes_ pour ces nouvelles pages dans `web/src/Routes.js`
- Ajout de trois _cells_ dans `web/src/components`:
  - `EditPostCell` cellule permettant de rÃ©cupÃ©rer un article pour l'Ã©diter
  - `PostCell` cellule permettant de rÃ©cupÃ©rer un article pour l'afficher
  - `PostsCell` cellule permettant de rÃ©cupÃ©rer tous les articles
- Ajout de quatre _composants_ Ã©galement dans `web/src/components`:
  - `NewPost` affiche le formulaire permettant la crÃ©ation d'un nouvel article
  - `Post` affiche un article en particulier
  - `PostForm` le formulaire utilisÃ© Ã  la fois par les composants de crÃ©ation et d'Ã©dition d'un aricle 
  - `Posts` affiche la table avec l'ensemble des articles

> **GÃ©nÃ©rateurs et conventions de nommage**
>
> Vous remarquerez que certains fichiers gÃ©nÃ©rÃ©s ont un nom au pluriel, et d'autres au singulier. Cette convention est empruntÃ©e au framework Ruby on Rails. Lorsque vous avez Ã  traiter d'un multiple de quelque chose (comme par exemple une liste d'articles), on utilisera le pluriel. Dans le cas contraire (par exemple la crÃ©ation d'un nouvel article), on utilisera le singulier. C'est aussi plus naturel lorsque l'on parle: "montre moi une liste d'articles" vs. "je vais crÃ©er un nouvel article".
>
> Pour ce qui concerne les gÃ©nÃ©rateurs:
>
> - Les fichiers de Services sont toujours au pluriel.
> - Les mÃ©thodes dans les Services sont au singulier ou au pluriel selon qu'ils retournent plusieurs articles ou un seul article (`posts` vs. `createPost`).
> - les fichiers SDL sont toujours au pluriel.
> - Les pages gÃ©nÃ©rÃ©es par une commande de scaffold sont au pluriel ou au singulier selon que la page manipule plusieurs ou un seul article. Notez que lorsque vous utilisez vous-mÃªme un commande `page` en dehors d'un scaffold, le nom utilisÃ© sera simplement celui que vous donnerez.
> - Les Layouts utilisent le nom que vous leur donnez
> - Les composants et les cellules sont au pluriel ou au singulier selon le contexte lorsqu'ils sont gÃ©nÃ©rÃ©s par scaffolding. Dans le cas contraire, ils utilisent simplement le nom que vous leur donnez.
>
> Remarquez Ã©galement que seul le nom de la table en base de donnÃ©es et au singulier ou au pluriel, et pas le mot complet. Ainsi on a `PostsCell`, et non `PostCells`. 
>
> Vous n'avez pas Ã  suivre cette convention de faÃ§on obligatoire lorsque vous crÃ©ez vos propres composants, pages, etc... Ceci Ã©tant nous vous le recommandons chaudement. Au bout du compte, la communautÃ© Ruby on Rails a fini par s'attacher Ã  cette convention, et ce mÃªme si au dÃ©part de nombreuses personnes s'y Ã©taient opposÃ©es. "[Give it five minutes](https://signalvnoise.com/posts/3124-give-it-five-minutes)" comme disent les anglo-saxons.

### CrÃ©er la page d'accueil

Nous pouvons commencer Ã  remplacer ces pages les unes aprÃ¨s les autres au fur et Ã  mesure que l'Ã©quipe chargÃ©e du design nous donne des Ã©lÃ©ments, ou bien nous pouvons simplement les dÃ©placer dnas la partie "administration" de notre site, et commencer Ã  crÃ©er nos propres pages. Ceci Ã©tant, la partie publique du site ne va certainement pas autoriser les utilisateurs Ã  crÃ©er, Ã©diter ou supprimer les articles. Que peuvent donc faire les utilisateurs?

1. Voir la liste des articles (sans liens pour Ã©diter ou supprimer)
2. Voir le dÃ©tail d'un article

Puisque nous voudront probablement conserver un moyen de crÃ©er et Ã©diter des articles plus tard, conservons les pages gÃ©nÃ©rÃ©es par scaffolding et crÃ©ons-en de nouvelles pour ces deux cas de figure.

Nous avons dÃ©jÃ  la `HomePage`, pas besoin de crÃ©er celle-ci donc. Nous souhaitons afficher une liste d'articles Ã  l'utilisateur donc nous allons devoir ajouter Ã§a. Nous avons besoin de rÃ©cupÃ©rer le contenu depuis la base de donnÃ©es, et nous ne voulons pas que l'utilisateur soit face Ã  une page blanche le temps du chargement (conditions rÃ©seau dÃ©gradÃ©es, serveur gÃ©ographiquement distant, etc...), donc nous voudrons montrer une sorte de message de chargement et/ou une animation. D'autre part, si une erreur se produit, nous devrons faire en sorte de la prendre en charge. Enfin, nous devrons Ã©galement prendre en compte le cas oÃ¹ le blog ne contient encore aucun article. 

Wow... notre premiÃ¨re page et il semble que nous ayons dÃ©jÃ  Ã  nous inquiÃ©ter de tant de choses... mais est-ce vÃ©ritablement le cas ? 

## Cells

Ce que nous cherchons Ã  faire ici constituent en rÃ©alitÃ© des objectifs partagÃ©s par la plupart des applications web. Nous voulions voir s'il Ã©tait possible de faciliter la vie aux dÃ©veloppeurs. Nous pensons Ãªtre arrivÃ© Ã  rÃ©aliser quelque chose d'utile. Nous appelons Ã§a les _Cells_ (ou _cellules_ en franÃ§ais). Les Cells proposent une approche simple et dÃ©clarative pour rÃ©cupÃ©rer des donnÃ©es au sein de vos composants. (Vous pouvez lire la documentation complÃ¨te Ã  propos des Cells. You can read the full documentation about Cells [ici](https://redwoodjs.com/docs/cells).

Lorsque vous crÃ©ez une nouvelle Cell, vous exportez quelques constantes, toujours nommÃ©es de faÃ§on identique, et Redwood s'appuie dessus pour mettre en place la mÃ©canique. Une Cell ressemble typiquement Ã  ceci:

```javascript
export const QUERY = gql`
  query {
    posts {
      id
      title
      body
      createdAt
    }
  }
`

export const Loading = () => <div>Chargement...</div>

export const Empty = () => <div>Aucun article disponible!</div>

export const Failure = ({ error }) => (
  <div>Erreur lors du chargement des articles: {error.message}</div>
)

export const Success = ({ posts }) => {
  return posts.map((post) => (
    <article>
      <h2>{post.title}</h2>
      <div>{post.body}</div>
    </article>
  ))
}
```

Lorsque React affiche ce composant, Redwood va:

- ExÃ©cuter la requÃªte `QUERY` et afficher le composant `Loading` jusqu'Ã  ce qu'une rÃ©ponse soit reÃ§ue
- Lorsque la requÃªte retourne une rÃ©ponse, il va afficher un des trois Ã©tats suivants:
  - S'il y a eu une erreur, le composant `Failure`
  - Si aucune donnÃ©e n'est retournÃ©e (c'est Ã  dire `null` ou un tableau vide), le composant `Empty`
  - Dans le cas contraire (ni erreur, ni vide), le composant `Success`

Il existe Ã©galement quelques outils supplÃ©mentaire pour gÃ©nÃ©rer le cycle de vie du composant comme `beforeQuery` (pour manipuler les propriÃ©tÃ©s passÃ©es Ã  `QUERY`) et `afterQuery` (pour manipuler les donnÃ©es retournÃ©es par GraphQL avant qu'elles ne soient transmises au composant `Success`)

Le minimum dont vous avez besoin pour une Cell sont les exports `QUERY` et `Success`. Si vous n'exportez pas `Empty`, `Success` recevra les donnÃ©es vides. Si vous n'exportez pas `Failure`, les Ã©ventuelles erreurs seront envoyÃ©es Ã  la console.

Pour dÃ©terminer dans quels cas utiliser les Cells, gardez en tÃªte qu'elles sont utiles lorsque vos composants ont besoin de rÃ©cupÃ©rer des donnÃ©es depuis la base, ou depuis tout autre service qui pourrait avoir un dÃ©lai de rÃ©ponse. Laissez Redwood se charger de jongler avec les Ã©tats, de maniÃ¨re Ã  pouvoir porter votre attention sur le comportement attendu de vos composants correctement affichÃ©s avec leur donnÃ©es.

### Notre PremiÃ¨re Cell

La page d'accueil affichant une liste d'articles est un candidat parfait pour rÃ©aliser notre premiÃ¨re cellule. Naturellement, nous avons prÃ©vu un gÃ©nÃ©rateur pour Ã§a:

    yarn rw g cell BlogPosts

L'exÃ©cution de cette commande provoque la crÃ©ation d'un nouveau fichier `/web/src/components/BlogPostsCell/BlogPostsCell.js` (et son fichier de test associÃ©) avec un peu de code par dÃ©faut pour vous faciliter la tÃ¢che:

```javascript
// web/src/components/BlogPostsCell/BlogPostsCell.js

export const QUERY = gql`
  query BlogPostsQuery {
    blogPosts {
      id
    }
  }
`

export const Loading = () => <div>Loading...</div>

export const Empty = () => <div>Empty</div>

export const Failure = ({ error }) => <div>Error: {error.message}</div>

export const Success = ({ blogPosts }) => {
  return JSON.stringify(blogPosts)
}
```
> Lorsque vous utilisez le gÃ©nÃ©rateur, vous pouvez employer le type de casse qui vous plaÃ®t. Redwood fera en sorte de s'adapter pour crÃ©er une cellule avec un nom de fichier correct. Ainsi toutes les commandes ci-dessous aboutissent Ã  crÃ©er un fichier avec le mÃªme nom:
>
>     yarn rw g cell blog_posts
>     yarn rw g cell blog-posts
>     yarn rw g cell blogPosts
>     yarn rw g cell BlogPosts
>
> Vous devez juste pensez Ã  indiquer d'une faÃ§on ou d'une autre que vous utilisez plusieurs mots. Appeler `yarn redwood g cell blogposts` sans utiliser aucune casse pour sÃ©parer "blog" et "posts" va gÃ©nÃ©rer un fichier `web/src/components/BlogpostsCell/BlogpostsCell.js`.  

Pour vous aider Ã  Ãªtre efficace, le gÃ©nÃ©rateur suppose que vous utiliserez une requÃªte racine GraphQL nommÃ©es de la mÃªme faÃ§on que votre Cell et Ã©crit pour vous une requÃªte minimale pour rÃ©cupÃ©rer des donnÃ©es depuis la base. Dans le cas prÃ©sent, la requÃªte a donc Ã©tÃ© nommÃ©e `blogPosts`. Cependant, ce nom de requÃªte n'est pas valide par rapport Ã  ce qui a dÃ©jÃ  Ã©tÃ© crÃ©Ã© dans nos fichiers SDL et Service. Nous devons donc renommer `blogPosts` en `posts` Ã  la fois dans le nom de la requÃªte GraphQL et dans la propriÃ©tÃ© passÃ©e Ã  `Success`: 

```javascript{5,17,18}
// web/src/components/BlogPostsCell/BlogPostsCell.js

export const QUERY = gql`
  query BlogPostsQuery {
    posts {
      id
    }
  }
`

export const Loading = () => <div>Loading...</div>

export const Empty = () => <div>Empty</div>

export const Failure = ({ error }) => <div>Error: {error.message}</div>

export const Success = ({ posts }) => {
  return JSON.stringify(posts)
}
```

InsÃ©rons cette Cell dans notre `HomePage` et voyons ce qui se passe:

```javascript{4,9}
// web/src/pages/HomePage/HomePage.js

import BlogLayout from 'src/layouts/BlogLayout'
import BlogPostsCell from 'src/components/BlogPostsCell'

const HomePage = () => {
  return (
    <BlogLayout>
      <BlogPostsCell />
    </BlogLayout>
  )
}

export default HomePage
```

Le navigateur devrait en principe montrer un tableau avec un peu de contenu (en supposant que vous ayez crÃ©Ã© un article Ã  l'Ã©tape du [scaffolding](/tutorial/getting-dynamic#creating-a-post-editor) un peu plus tÃ´t). Impeccable!

<img src="https://user-images.githubusercontent.com/300/73210519-5380a780-40ff-11ea-8639-968507a79b1f.png" />

> **Dans le composant `Success`, d'oÃ¹ vient donc `posts`?**
>
> Remarquez que dans le composant `QUERY`, nous avons nommÃ©e notre requÃªte `posts`. Quelque soit le nom de la requÃªte, ce sera le nom de la propriÃ©tÃ© qui sera transmise au composant `Success` et qui  contiendra vos donnÃ©es. Vous pouvez toutefois crÃ©er un alias de la faÃ§on suivante:  
>
> ```javascript
> export const QUERY = gql`
>   query BlogPostsQuery {
>     postIds: posts {
>       id
>     }
>   }
> `
> ```
>
> De cette maniÃ¨re la propriÃ©tÃ© `postIds` sera transmise Ã  `Success` au lieu de `posts`

En plus de l'identifiant `id` qui a Ã©tÃ© ajoutÃ© dans `QUERY` par le gÃ©nÃ©rateur, rÃ©cupÃ©rons Ã©galement le titre, le contenu et la date de crÃ©ation de l'article:

```javascript{7-9}
// web/src/components/BlogPostsCell/BlogPostsCell.js

export const QUERY = gql`
  query BlogPostsQuery {
    posts {
      id
      title
      body
      createdAt
    }
  }
`
```

La page devrait dÃ©sormais afficher un dump de l'ensemble des donnÃ©es pour tous les articles enregistrÃ©s:

<img src="https://user-images.githubusercontent.com/300/73210715-abb7a980-40ff-11ea-82d6-61e6bdcd5739.png" />

`Success` est ni plus ni moins qu'un bon vieux composant React, vous pouvez donc le modifier simplement pour afficher chaque article dans un format un peu plus sympa et lisible:

```javascript{4-12}
// web/src/components/BlogPostsCell/BlogPostsCell.js

export const Success = ({ posts }) => {
  return posts.map((post) => (
    <article key={post.id}>
      <header>
        <h2>{post.title}</h2>
      </header>
      <p>{post.body}</p>
      <div>CrÃ©Ã© le: {post.createdAt}</div>
    </article>
  ))
}
```

Et ce faisant, nous avons maintenant notre blog! Ok, Ã  ce stade c'est encore le plus basique et hideux blog jamais vu sur Internet.. mais c'est dÃ©jÃ  quelque chose! (Pas d'inquiÃ©tude, nous avons encore un tas de fonctionnalitÃ©s Ã  ajouter)

<img src="https://user-images.githubusercontent.com/300/73210997-3dbfb200-4100-11ea-847a-602cbf59cb2a.png" />

### RÃ©sumÃ©

Pour rÃ©sumer, qu'avons nous rÃ©alisÃ© jusqu'ici ?

1. GÃ©nÃ©ration de la page d'accueil
2. GÃ©nÃ©ration du Layout pour notre blog
3. DÃ©finition du schÃ©ma de la base de donnÃ©es
4. Application d'une migrations pour mettre Ã  jour la base de donnÃ©es et crÃ©er une table
5. RÃ©alisation d'un Scaffold pour crÃ©er une interface CRUD sur la table
6. CrÃ©ation d'une Cell pour charger les donner et gÃ©rer les Ã©tats "loading", "empty", "failure" et enfin "success". 
7. Ajout de la Cell Ã  notre page d'accueil

En rÃ©alitÃ©, cette diffÃ©rentes Ã©tapes sont ni plus ni moins ce qui deviendra votre faÃ§on habituelle d'ajouter de nouvelles fonctionnalitÃ©s dans une application Redwood.

Jusqu'ici, hormis un peu de code HTML, nous n'avons pas Ã©crit grand chose Ã  la main. En particulier, nous n'avons pratiquement pas eu Ã  Ã©crire de code pour rÃ©cupÃ©rer les donnÃ©es depuis la base. Le dÃ©veloppement web s'en trouve facilitÃ© et devient mÃªme agrÃ©able, qu'en pensez-vous?

## QuÃªte secondaire: Fonctionnement de Redwood avec les DonnÃ©es

Redwood apprÃ©cie GraphQL. Nous pensons qu'il s'agit de l'API pour l'avenir. Notre implÃ©mentation de GraphQL is construite avec [Apollo](https://www.apollographql.com/). Voici comment une requÃªte GraphQL classique fonctionne dans votre application: 

![Redwood Data Flow](https://user-images.githubusercontent.com/300/75402679-50bdd180-58ba-11ea-92c9-bb5a5f4da659.png)

La partie frontend de l'application s'appuie sur [Apollo Client](https://www.apollographql.com/docs/react/) pour crÃ©er une requÃªte GraphQL. Celle-ci est ensuite envoyÃ©e Ã  [Apollo Server](https://www.apollographql.com/docs/apollo-server/) qui s'exÃ©cute dans une fonction lambda AWS serverless.  

Les fichiers `*.sdl.js` qui se trouvent dans le rÃ©pertoire `api/src/graphql` dÃ©finissent les types GraphQL [Object](https://www.apollographql.com/docs/tutorial/schema/#object-types), [Query](https://www.apollographql.com/docs/tutorial/schema/#the-query-type) et [Mutation](https://www.apollographql.com/docs/tutorial/schema/#the-mutation-type) et donc l'interface de votre API.

En principe, vous devriez Ã©crire une "[resolver map](https://www.apollographql.com/docs/tutorial/resolvers/#what-is-a-resolver)" qui contiendrait l'ensemble de vos "resolvers" de faÃ§on Ã  ce qu'Apollo sache comment les brancher Ã  vos fichiers SDL. Cependant, inscrire votre logique mÃ©tier directement dans votre "resolver map" aurait pour consÃ©quence la crÃ©ation d'un Ã©norme fichier ne favorisant pas la rÃ©utilisation. Vous pourriez Ã©galement extraire toute cette logique dans une librairie de fonctions que vous importeriez et appelleriez depuis votre "resolver map", en ayant toutefois Ã  vous rappeller de passer tous les arguments nÃ©cessaires. Humm.. c'est beaucoup d'efforts pour au final une masse de code de toute faÃ§on peu rÃ©utilisable.

Redwood s'y prend autrement! Voos rappellez-vous le rÃ©pertoire `api/src/services`? Redwood va automatiquement importer et brancher vos "resolvers" depuis les **services** vers vos fichiers SDL. Dans le mÃªme temps, Redwood vous permet d'Ã©crire vos "resolvers" de faÃ§on Ã  ce qu'ils soient facilement appellÃ©s comme de simples fonctions depuis d'autres "resolvers" ou d'autres services. Cela fait pas mal de choses Ã©tonnantes Ã  intÃ©grer, il est temps de passer Ã  un exemple.

Observez donc le morceau de code SDL javascript suivant :

```javascript
// api/src/graphql/posts.sdl.js

export const schema = gql`
  type Post {
    id: Int!
    title: String!
    body: String!
    createdAt: DateTime!
  }

  type Query {
    posts: [Post!]!
    post(id: Int!): Post!
  }

  input CreatePostInput {
    title: String!
    body: String!
  }

  input UpdatePostInput {
    title: String
    body: String
  }

  type Mutation {
    createPost(input: CreatePostInput!): Post!
    updatePost(id: Int!, input: UpdatePostInput!): Post!
    deletePost(id: Int!): Post!
  }
`
```

A partir de ce fichier SDL, Redwood va aller chercher les cinq "resolvers" suivants dans `api/src/services/posts/posts.js` :

- `posts()`
- `post({id})`
- `createPost({input})`
- `updatePost({id, input})`
- `deletePost({id})`

Pour implÃ©menter ces cinq "resolvers", il vous suffit de les exporter depuis vos fichiers services. Vos resolvers vont habituellement rÃ©cupÃ©rer les donnÃ©es depuis une base de donnÃ©es, mais en rÃ©alitÃ© ils peuvent faire ce que vous souhaitez du moment qu'ils retournent le type de donnÃ©es qu'Apollo s'attend Ã  recevoir comme dÃ©fini dans `posts.sdl.js`. 

```javascript
// api/src/services/posts/posts.js
import { db } from 'src/lib/db'

export const posts = () => {
  return db.post.findMany()
}

export const post = ({ id }) => {
  return db.post.findOne({
    where: { id },
  })
}

export const createPost = ({ input }) => {
  return db.post.create({
    data: input,
  })
}

export const updatePost = ({ id, input }) => {
  return db.post.update({
    data: input,
    where: { id },
  })
}

export const deletePost = ({ id }) => {
  return db.post.delete({
    where: { id },
  })
}
```

> Apollo suppose que ces fonctions retournent des "promises", ce que `db` fait parfaitement. `db` est une instance de `PrismaClient`. Apollo attend sagement que ces promises s'achÃ¨vent avant de rÃ©pondre avec le rÃ©sultat de vos requÃªtes. De cette maniÃ¨re, vous n'avez pas Ã  gÃ©rer vous-mÃªme les `async`/`await`, ou autres callbacks. 

Vous Ãªtes parfaitement fondÃ© Ã  vous interroger sur la raison pour laquelle nous appelons ces fichiers des "services". Bien que le blog que nous construisons ensemble ne soit pas assez complexe pour le montrer, les services sont conÃ§us pour Ãªtre une abstraction qui couvre **plus** qu'une simple table de la base de donnÃ©es. Une application plus avancÃ©e pourrait par exemple avoir un service nommÃ© "facturation" qui reposerait Ã  fois sur les tables `transactions` et `souscriptions`. Certaines des fonctionnalitÃ©s de ce service pourraient Ãªtre exposÃ©es via GraphQL, mais pas forcÃ©ment toutes. 

Vous n'avez pas besoin d'exposer chaque fonction de votre service via GraphQL. Si vous ne les dÃ©clarez pas dans dans vos types `Query` ou `Mutation`, ils n'existerons tout simplement pas pour GraphQL. Mais vous pourrez toujours les utiliser vous-mÃªme. Les services ne sont ni plus ni moins que des fonctions javascript que vous pouvez utiliser oÃ¹ bon vous semble :

- Depuis un autre service
- Dans une autre fonction lambda crÃ©Ã©e par vous-mÃªme
- Depuis une autre API, complÃ¨tement sÃ©parÃ©e

En organisant votre application autour de services bien dÃ©finis, et en proposant une API pour chacun de ces services (Ã  la fois pour un usage interne, **et** pour GraphQL), vous contribuerez naturellement Ã  respecter la rÃ¨gle dite de ["separation of concerns"](https://fr.wikipedia.org/wiki/S%C3%A9paration_des_pr%C3%A9occupations) (SoC). Selon toute probabilitÃ©, cela vous permettra de favoriser la maintenance de votre code dans le temps.

Revenons-en Ã  notre flux de donnÃ©es: Apollo a crÃ©Ã© un "resolver" qui, dans notre cas, rÃ©cupÃ¨re les donnÃ©es depuis une base de donnÃ©es. Apollo reconstruit l'objet en ne retournant que les couples clÃ©/valeur demandÃ©s dans la requÃªte GraphQL. Enfin, Apollo emballe la rÃ©ponse au format GraphQL et la retourne au navigateur.

Si vous utilisez une **Cell** Redwood, vos donnÃ©es seront dÃ¨s lors disponible dans votre compsant `Success`, prÃªtes Ã  Ãªtre affichÃ©es comme avec n'importe quel composant React.

## ParamÃ¨tres de Routes

Maintenant que notre page d'accueil liste l'ensemble des articles de notre blog, il est temps de crÃ©er une page prÃ©sentant le dÃ©tail d'un article. CommenÃ§ons par gÃ©nÃ©rer une page et sa route associÃ©e:

    yarn rw g page BlogPost

> Remarquez que nous ne pouvons pas nommer cette page `Post` car une autre page homonyme a dÃ©jÃ  Ã©tÃ© crÃ©e lors de notre prÃ©cÃ©dente dÃ©monstration du scaffolding.

Pour chaque article listÃ© sur la page d'accueil, ajoutons un lien qui pointe vers notre nouvelle page (sans oublier au passage les imports pour `Link` et `routes`):

```javascript{3,12}
// web/src/components/BlogPostsCell/BlogPostsCell.js

import { Link, routes } from '@redwoodjs/router'

// QUERY, Loading, Empty and Failure definitions...

export const Success = ({ posts }) => {
  return posts.map((post) => (
    <article key={post.id}>
      <header>
        <h2>
          <Link to={routes.blogPost()}>{post.title}</Link>
        </h2>
      </header>
      <p>{post.body}</p>
      <div>CrÃ©Ã© le: {post.createdAt}</div>
    </article>
  ))
}
```

Si vous cliquez sur le lien, vous deviez voir s'afficher un peu de texte issu de `BlogPostPage`. Mais ce dont nous avons vraiment besoin, c'est de pouvoir prÃ©ciser _quel_ article nous souhaitons afficher. Ce que nous cherchons a obtenir en dÃ©finitive, c'est une URL du type `/blog-post/1`. Pour cela, nous allons dire au routeur que notre url comporte une partie variable supplÃ©mentaire:

```html
// web/src/Routes.js

<Route path="/blog-post/{id}" page={BlogPostPage} name="blogPost" />
```

Notez l'ajout de `{id}` dans notre route. Redwood nomme ceci un _paramÃ¨tre de route_. Ces paramÃ¨tres de route signifie la chose suivante: "quelque soit la valeur Ã  cette position, elle sera rÃ©fÃ©rencÃ©e par le nom utilisÃ© entre les accolades".

Cool, cool, cool. Maintenant, nous devons donc construire un lien qui possÃ¨de cet identifiant:

```html
// web/src/components/BlogPostsCell/BlogPostsCell.js

<Link to={routes.blogPost({ id: post.id })}>{post.title}</Link>
```

Pour les routes avec paramÃ¨tres, un objet est attendu pour chaque paramÃ¨tre. Si vous cliquez sur le lien d'un article, vous constaterez qu'en effet il pointe dÃ©sormais vers `/blog-post/1` (ou `/blog-post/2`, etc... selon l'article).

### Utilisation des ParamÃ¨tres

OK, donc l'identifiant se trouve bien dans l'URL. Et maintenant que fait-t-on pour afficher le bon article? On dirait bien que nous allons devoir rÃ©cupÃ©rer les donnÃ©es depuis la base. Vous l'aurez compris, c'est le bon moment pour utiliser une Cell:

    yarn rw g cell BlogPost

Nous allons ensuite utiliser cette Cell dans notre page `BlogPostPage` (et pendant que nous y sommes, nous insÃ¨rerons notre page dans notre Layout `BlogLayout`):

```javascript
// web/src/pages/BlogPostPage/BlogPostPage.js

import BlogLayout from 'src/layouts/BlogLayout'
import BlogPostCell from 'src/components/BlogPostCell'

const BlogPostPage = () => {
  return (
    <BlogLayout>
      <BlogPostCell />
    </BlogLayout>
  )
}

export default BlogPostPage
```

Maintenant, Ã  l'intÃ©rieur de notre Cell, nous avons besoin d'accÃ©der Ã  ce paramÃ¨tre de route `{id}` qui contient l'identifiant de notre article en base de donnÃ©es. Pour ce faire, mettons Ã  jour la requÃªte de faÃ§on Ã  ce qu'elle accepte une variable en entrÃ©e. Modifions Ã©galement le nom de la requÃªte `blogPost` en `post`.

```javascript{4,5,7-9,20,21}
// web/src/components/BlogPostCell/BlogPostCell.js

export const QUERY = gql`
  query BlogPostQuery($id: Int!) {
    post(id: $id) {
      id
      title
      body
      createdAt
    }
  }
`

export const Loading = () => <div>Loading...</div>

export const Empty = () => <div>Empty</div>

export const Failure = ({ error }) => <div>Error: {error.message}</div>

export const Success = ({ post }) => {
  return JSON.stringify(post)
}
```

Okay, on approche du but! Ceci Ã©tant, d'oÃ¹ vient donc ce `$id`? Redwood a plus d'un tour dans son sac. Chaque fois que vous ajoutez un paramÃ¨tre de route, ce paramÃ¨tre est automatiquement accessible dans la page qui correspond. Ce qui signifie que vous pouvez modifier la page `BlogPostPage` de la faÃ§on suivante:

```javascript{3,6}
// web/src/pages/BlogPostPage/BlogPostPage.js

const BlogPostPage = ({ id }) => {
  return (
    <BlogLayout>
      <BlogPostCell id={id} />
    </BlogLayout>
  )
}
```

`id` existe dÃ©jÃ  sans effort supplÃ©mentaire puisque nous avons nommÃ© notre paramÃ¨tre de route `{id}`. Merci qui? Merci Redwood! Mais comment se fait-il que cet `id` finisse par devenir un paramÃ¨tre GraphQL `$id`? Redwood s'en charge Ã©galement pour vous! Par dÃ©faut, chaque propriÃ©tÃ© que vous donnez Ã  une Cell devient automatiquement un variable disponible pour une requÃªte GraphQL. Incroyablement simple, et pourtant vrai :)

D'ailleurs on peut le prouver! Essayez maintenant d'aller voir un article and â€” ... uh oh. Hmm:

![image](https://user-images.githubusercontent.com/300/75820346-096b9100-5d51-11ea-8f6e-53fda78d1ed5.png)

> Au passage le code d'erreur que vous voyez s'afficher provient de la section `Failure` de votre Cell!

Si vous examinez la console de votre navigateur, vous constaterez la prÃ©sence d'une erreur GraphQL:

    [GraphQL error]: Message: Variable "$id" got invalid value "1";
      Expected type Int. Int cannot represent non-integer value: "1",
      Location: [object Object], Path: undefined

Il s'avÃ¨re que les paramÃ¨tres de route sont extraits des URL sous la forme de chaÃ®nes de caractÃ¨res, et dans le cas prÃ©sent GraphQL s'attend Ã  recevoir un identifiant sous la forme d'un entier. Nous pourrions simplement utiliser la fonction javascript `parseInt()` afin de convertir notre paramÃ¨tre de route vers un entier avant de le passer Ã  `BlogPostCell`. Mais honnÃªtement, on peut faire bien mieux que Ã§a! 

### ParamÃ¨tres de Route TypÃ©s

Et si vous aviez la possibilitÃ© de demander cette conversion directement dans le chemin de la route? Et bien devinez-quoi, vous pouvez! Redwood appelle Ã§a les **paramÃ¨tres de route typÃ©s** ("route param types" en anglais). Et c'est aussi simple que d'ajouter `:Int` Ã  notre paramÃ¨tre de route:
What if you could request the conversion right in the route's path? Well, guess what: you can! Introducing **route param types**. It's as easy as adding `:Int` to our existing route param:

```html
// web/src/Routes.js

<Route path="/blog-post/{id:Int}" page={BlogPostPage} name="blogPost" />
```

VoilÃ ! Non seulement vous allez convertir sans effort le paramÃ¨tre `id` en un entier avant de la passer Ã  votre Page, mais en bonus vous faÃ®tes en sorte que la route n'applique que si `id` reprÃ©sente effectivement un entier, c'est Ã  dire une suite de chiffres. Dans le cas contraire, le routeur essaiera d'autres routes. S'il ne s'en trouve aucune Ã  s'appliquer, le routeur affichera la page `NotFoundPage`.

> **Que se passe-t-il si je veux passer d'autres propriÃ©tÃ©s Ã  ma Cell dont je n'ai pas besoin dans la requÃªte, mais qui me sont utile dans les composants Success/Loader/etc... ?**
>
> Toutes les propriÃ©tÃ©s que vous donnez Ã  votre Cell seront automatiquement disponibles pour ses composants internes. Seuls ceux qui se se trouvent dans la liste des variables GraphQL seront transmises Ã  la requÃªte. Vous avez ainsi le meilleur des deux mondes! Dans l'affichage de notre article ci-dessus, si vous dÃ©sirez montrer par exemple un nombre au hasard (pour des raisons evidentes liÃ©es Ã  ce didacticiel :D), il vous suffit de passer cette propriÃ©tÃ© Ã  votre Cell:
>
> ```javascript
> <BlogPostCell id={id} rand={Math.random()} />
> ```
> 
> Et ensuite vous la rÃ©cupÃ©rez avec le rÃ©sulat de la requÃªte ans le composant (et mÃªme avec l'identifiant de l'article si vous le souhaitez):
> And get it, along with the query result (and even the original `id` if you want) in the component:
>
> ```javascript
> export const Success = ({ post, id, rand }) => {
>   //...
> }
> ```
>
> Merci Redwood!

### Displaying a Blog Post

Maintenant, affichons un vÃ©ritable article au lieu d'un simple dump du rÃ©sultat de la requÃªte. Il semble que ce soit l'endroit parfait pour utiliser un bon vieux composant puisque nous affichons les articles de faÃ§on identique (pour l'instant) Ã  la fois sur la page d'accueil et sur la page de dÃ©tail.

    yarn rw g component BlogPost

L'exÃ©cution de cette commande crÃ©Ã© le composant `BlogPost` dans le fichier `web/src/components/BlogPost/BlogPost.js`, accompagnÃ© de son fichier de test: 

```javascript
// web/src/components/BlogPost/BlogPost.js

const BlogPost = () => {
  return (
    <div>
      <h2>{'BlogPost'}</h2>
      <p>{'Find me in ./web/src/components/BlogPost/BlogPost.js'}</p>
    </div>
  )
}

export default BlogPost
```

> Vous remarquerez peut-Ãªtre que nous n'avons ici aucun `import` relatif Ã  la librairie `React`. Il s'agit pourtant bien d'un classique composant React. En rÃ©alitÃ©, nous (la "Redwood dev team") sommes un peu fatiguÃ©s d'avoir Ã  importer constamment les mÃªmes fichiers de la mÃªme maniÃ¨re... alors nous avons fait en sorte que Redwood le fasse pour nous, et donc pour vous!

Supprimons la partie de code qui affiche l'article dans `BlogPostCell`, et mettons la plutÃ´t ici. Ce faisant, passons Ã  notre nouveau composant la propriÃ©tÃ© `post`:

```javascript{3,5,7-14}
// web/src/components/BlogPost/BlogPost.js

import { Link, routes } from '@redwoodjs/router'

const BlogPost = ({ post }) => {
  return (
    <article>
      <header>
        <h2>
          <Link to={routes.blogPost({ id: post.id })}>{post.title}</Link>
        </h2>
      </header>
      <div>{post.body}</div>
    </article>
  )
}

export default BlogPost
```

Mettons Ã  jour `BlogPostsCell` et `BlogPostCell` pour utiliser notre composant d'affichage commun:

```javascript{3,8}
// web/src/components/BlogPostsCell/BlogPostsCell.js

import BlogPost from 'src/components/BlogPost'

// Loading, Empty, Failure...

export const Success = ({ posts }) => {
  return posts.map((post) => <BlogPost key={post.id} post={post} />)
}
```

```javascript{3,8}
// web/src/components/BlogPostCell/BlogPostCell.js

import BlogPost from 'src/components/BlogPost'

// Loading, Empty, Failure...

export const Success = ({ post }) => {
  return <BlogPost post={post} />
}
```

Et nous y sommes! Nous devrions maintenant pouvoir aller et venir Ã  notre guise entre la page d'accueil et les articles.

> Si vous apprÃ©ciez ce que vous venez de voir sur le routeur, vous pouvez en apprendre plus dans le [guide](/docs/redwood-router) qui lui est consacrÃ©. 

### RÃ©sumÃ©

Un petit Ã©tat des lieux de ce que nous avons rÃ©alisÃ©:

1. CrÃ©ation d'une nouvelle page pour afficher un article
2. Ajout d'une route prenant en char l'identifiant `id` d'un article sous la forme d'un paramÃ¨tre de route
3. CrÃ©ation d'une Cell permettant de rÃ©cupÃ©rer et afficher un article
4. Constat de la capacitÃ© de Redwood Ã  vous mettre de bonne humeur en vous donnant accÃ¨s Ã  `id` lÃ  oÃ¹ vous en avez besoin tout en le convertissant au format numÃ©rique Ã  la volÃ©e
6. Transformation de l'affichage d'un article en un composant React classique pouvant Ãªtre partagÃ© Ã  plusieurs endroits dans l'interface (en l'espÃ¨ce dans la page d'accueil et la page de dÃ©tail)

## Votre partie prÃ©fÃ©rÃ©e: Les Formulaires

Attendez! Ne partez pas! Vous deviez bien vous douter que Ã§a allait venir, non? Rassurez-vous, pour les formulaires aussi, Redwood a trouvÃ© une faÃ§on de faire qui les rend moins pÃ©nible que d'habitude. En fait, Redwood pourrait mÃªme vous faire _aimer_ les formulaires. Bon, aimer est peut-Ãªtre un peu fort. Disons _apprÃ©cier_ travailler avec les formulaires, ou Ã  tout le moins les _tolÃ©rer_?   

La troisiÃ¨me partie du didacticiel en video commence ici:

<div class="relative pb-9/16">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/eT7iIy0F8Tk?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

Nous avons dÃ©jÃ  un formulaire ou deux dans notre application; vous rappellez-vous notre _scaffolding_ avec les articles? Ils fonctionnaient plus bien, non? Alors, a quel point est-ce difficile de reproduire ces formulaires? (Si vous n'avez pas encore eu la curiositÃ© d'aller voir le code gÃ©nÃ©rÃ©, ce qui va suivre va vous surprendre)

Construisons donc le formulaire le plus Ã©lÃ©mentaire qui soit pour notre blog, et utile de surcroÃ®t, celui qui permettra Ã  vos lecteurs de vous contacter. 

### La Page

    yarn rw g page contact

AprÃ¨s avoir exÃ©cutÃ© cette commande, nous pouvons ajouter un lien vers Contact dans notre Layout:

```javascript{17-19}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'

const BlogLayout = ({ children }) => {
  return (
    <>
      <header>
        <h1>
          <Link to={routes.home()}>Redwood Blog</Link>
        </h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
            <li>
              <Link to={routes.contact()}>Contact</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>{children}</main>
    </>
  )
}

export default BlogLayout
```

And then use the `BlogLayout` in the `ContactPage`:

```javascript{3,6}
// web/src/pages/ContactPage/ContactPage.js

import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  return <BlogLayout></BlogLayout>
}

export default ContactPage
```

VÃ©rifiez que tout fonctionne correctement, puis passons aux rÃ©jouÃ¯ssances.

### PrÃ©sentation des Form Helpers

Les formulaires avec React sont surtout connus pour Ãªtre particuliÃ¨rement agaÃ§ants Ã  construire. Il existes les [Controlled Components](https://reactjs.org/docs/forms.html#controlled-components), les [Uncontrolled Components](https://reactjs.org/docs/uncontrolled-components.html), diverses [librairies tierces](https://jaredpalmer.com/formik/) et enfin pas mal d'astuces diverses pour essayer de les rendre aussi simples qu'ils sont sensÃ©s Ãªtre selon les spÃ©cifications HTML: un champ `<input>` avec un attribut `name` qui sera envoyÃ© quelque part lorsque l'utilisateur clique sur un bouton.  

Nous pensons que Redwood fait quelques pas dans la bonne direction, non seulement en vous libÃ©rant d'avoir Ã  Ã©crire un tans de code relatif aux composants controllÃ©s (controlled components), mais aussi en s'occupant de gÃ©rer automatiquement les validations et Ã©ventuelles erreurs. Regardons ensemble comment tout celÃ  fonctionne.

Avant de commencer, ajoutons quelques classes CSS pour que les formulaires par dÃ©faut s'affichent correctement sans que nous ayons Ã  alourdir notre code avec des attributs `style` un peu partout. Pour le moment nous Ã©crirons ces rÃ¨gles dans le fichier `index.css` situÃ© dans le rÃ©pertoire `web/src`:

```css
/* web/src/index.css */

button, input, label, textarea {
  display: block;
  outline: none;
}

label {
  margin-top: 1rem;
}

.error {
  color: red;
}

input.error, textarea.error {
  border: 1px solid red;
}
```

Pour l'instant nous n'allons pas faire dialoguer notre formulaire de contact avec la base de donnÃ©es, raison pour laquelle nous ne gÃ©nÃ©rons pas une Cell. Nous allons simplement ajouter le formulaire Ã  notre page. Dans Redwood, la crÃ©ation d'un formulaire dÃ©bute par... attention Ã  la surprise...une balise `<Form>`:

```javascript{3,9}
// web/src/pages/ContactPage/ContactPage.js

import { Form } from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  return (
    <BlogLayout>
      <Form></Form>
    </BlogLayout>
  )
}

export default ContactPage
```

Humm, OK... pour le moment rien d'incroyable. Ajoutons un premier champ que l'on puisse au moins afficher quelque chose. Redwood propose une variÃ©tÃ© de type de champs parmi lesquels se trouve `<TextField>`. Ce dernier correspond Ã  un champ text tout ce qu'il y a de plus basique. Il possÃ¨de un attribut `name` de telle faÃ§on que lorsqu'un formulaire contient de multiples champs, il soit possible de savoir lequel contient telle ou telle donnÃ©e.

```javascript{3,10}
// web/src/pages/ContactPage/ContactPage.js

import { Form, TextField } from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  return (
    <BlogLayout>
      <Form>
        <TextField name="input" />
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

<img src="https://user-images.githubusercontent.com/300/80258121-4f4d2300-8637-11ea-83f5-c667e05aaf74.png" />

Enfin quelque chose s'affiche! Pas encore trÃ¨s intÃ©ressant toutefois. Ajoutons un bouton "envoyer".

```javascript{3,11}
// web/src/pages/ContactPage/ContactPage.js

import { Form, TextField, Submit } from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  return (
    <BlogLayout>
      <Form>
        <TextField name="input" />
        <Submit>Save</Submit>
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

<img src="https://user-images.githubusercontent.com/300/80258188-7572c300-8637-11ea-9583-1b7636f93be0.png" />

Nous obtenons ce qu'on peut considÃ©rer comme un vÃ©ritable et authentique formulaire! Essayez de saisir quelque chose et cliquez sur le bouton. Rien n'explose, mais nous n'avons aucune indication que le formulaire Ã  bien Ã©tÃ© envoyÃ© (et vous aurez notÃ© l'apparition d'une erreur dans la console). Voyons Ã  prÃ©sent comment rÃ©cupÃ©rer les donnÃ©es depuis nos champs de formulaire.

### onSubmit

De faÃ§on similaire Ã  un formulaire HTML, une balise `<Form>` possÃ¨de un "_handler_" `onSubmit`. Ce handler sera appelÃ© avec un seul argument: un unique objet contenant l'ensemble des champs du formulaire.

```javascript{4-6,10}
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = () => {
  const onSubmit = (data) => {
    console.log(data)
  }

  return (
    <BlogLayout>
      <Form onSubmit={onSubmit}>
        <TextField name="input" />
        <Submit>Save</Submit>
      </Form>
    </BlogLayout>
  )
}
```

Essayons maintenant de saisir quelques mots puis soumettre ce formulaire:

<img src="https://user-images.githubusercontent.com/300/80258293-c08cd600-8637-11ea-92fb-93d3ca1db3cf.png" />

Extra! Rendons le formulaire un peu plus utile en ajoutant quelques champs supplÃ©mentaires. Nous renommons ainsi notre premier champ en `name` puis ajoutons les champs `email` et `message`:

```javascript{3,15,16}
// web/src/pages/ContactPage/ContactPage.js

import { Form, TextField, TextAreaField, Submit } from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  const onSubmit = (data) => {
    console.log(data)
  }

  return (
    <BlogLayout>
      <Form onSubmit={onSubmit}>
        <TextField name="name" />
        <TextField name="email" />
        <TextAreaField name="message" />
        <Submit>Save</Submit>
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

Remarquez le nouveau composant `<TextAreaField>` qui gÃ©nÃ¨re une balise HTML `<textarea>` contenant quelques spÃ©cificitÃ©s utiles propres Ã  Redwood:

<img src="https://user-images.githubusercontent.com/300/80258346-e4e8b280-8637-11ea-908b-06a1160b932b.png" />

Ajoutons Ã©galement quelques Ã©tiquettes en face des champs:

```javascript{6,9,12}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Form onSubmit={onSubmit}>
      <label htmlFor="name">Name</label>
      <TextField name="name" />

      <label htmlFor="email">Email</label>
      <TextField name="email" />

      <label htmlFor="message">Message</label>
      <TextAreaField name="message" />

      <Submit>Save</Submit>
    </Form>
  </BlogLayout>
)
```

<img src="https://user-images.githubusercontent.com/300/80258431-15c8e780-8638-11ea-8eca-0bd222b51d8a.png" />

Essayez donc de soumettre Ã  nouveau le formulaire, vous devriez obtenir dans la console un message avec le contenu des trois champs.

### Validation

"Humm... cher auteur de ce didacticiel, qui a-t-il d'incroyable jusqu'ici?". C'est sans doute votre Ã©tat d'esprit Ã  ce stade. En effet, il existe dÃ©jÃ  un nombre consÃ©quent de librairies permettant d'obtenir un rÃ©sultat similaire.. Vous avez raison! N'importe qui peut remblir un formulaire _correctement_, mais que se passe-t-il lorsqu'un utilisateur fait une erreur, oubli un champ, voire tente de jouer les hackers? Qui va vous aider Ã  gÃ©rer cette situation? Redwood va le faire. 

Tout d'abord, ce trois champs devraient Ãªtre obligatoirement remplis pour pouvoir soumettre le formulaire. Rendons cette rÃ¨gle obligatoire en utilisant l'attribut HTML standard `required`:

```javascript{7,10,13}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Form onSubmit={onSubmit}>
      <label htmlFor="name">Name</label>
      <TextField name="name" required />

      <label htmlFor="email">Email</label>
      <TextField name="email" required />

      <label htmlFor="message">Message</label>
      <TextAreaField name="message" required />

      <Submit>Save</Submit>
    </Form>
  </BlogLayout>
)
```

<img src="https://user-images.githubusercontent.com/300/80258542-5163b180-8638-11ea-8450-8a727de177ad.png" />

DÃ©sormais, lorsque vous essayez de soumettre le formulaire, un message s'affiche dans votre navigateur. C'est mieux que rien, mais l'apparence de ce message ne peut Ãªtre modifiÃ©e. Peut-on faire mieux?

Oui! RemplaÃ§ons cet attribut `required` par un object que nous passons Ã  un attribut nommÃ© `validation`, spÃ©cifique Ã  Redwood:

```javascript{7,10,13}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Form onSubmit={onSubmit}>
      <label htmlFor="name">Name</label>
      <TextField name="name" validation={{ required: true }} />

      <label htmlFor="email">Email</label>
      <TextField name="email" validation={{ required: true }} />

      <label htmlFor="message">Message</label>
      <TextAreaField name="message" validation={{ required: true }} />

      <Submit>Save</Submit>
    </Form>
  </BlogLayout>
)
```

Maintenant lorsqu'un champ reste vide, le formulaire n'est pas envoyÃ© et le champ en question prend le focus de telle maniÃ¨re que l'utilisateur puisse saisir une valeur. Pas encore stupÃ©fiant, mais c'est une premiÃ¨re Ã©tape. Redwood a d'autres fonctions sympatiques pour les formulaires, dont la possibilitÃ© d'afficher les erreurs Ã  cÃ´tÃ© des champs.  


### `<FieldError>`

Pour celÃ , voici le composant `<FieldError>` (n'oubliez pas d'inclure l'`import` associÃ© en haut du fichier):

```javascript{8,22,26,30}
// web/src/pages/ContactPage/ContactPage.js

import {
  Form,
  TextField,
  TextAreaField,
  Submit,
  FieldError,
} from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  const onSubmit = (data) => {
    console.log(data)
  }

  return (
    <BlogLayout>
      <Form onSubmit={onSubmit}>
        <label htmlFor="name">Name</label>
        <TextField name="name" validation={{ required: true }} />
        <FieldError name="name" />

        <label htmlFor="email">Email</label>
        <TextField name="email" validation={{ required: true }} />
        <FieldError name="email" />

        <label htmlFor="message">Message</label>
        <TextAreaField name="message" validation={{ required: true }} />
        <FieldError name="message" />

        <Submit>Save</Submit>
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

Observez que l'attribut `name` correspond Ã  celui du champ au dessus. De cette maniÃ¨re, Redwood sait oÃ¹ afficher le message d'erreur d'un champ.

<img src="https://user-images.githubusercontent.com/300/80258694-ac95a400-8638-11ea-904c-dc034f07b12a.png" />

Mais c'est juste le dÃ©but. Maintenant faisons en sorte que nos utilisateurs sachent qu'il s'agisse bien d'un message d'erreur. Vous rappellez-vous la classe CSS `.error` que nous avions dÃ©finie dans `index.css`? Indiquons-la Ã  l'attribut `className` de nos composants `<FieldError>`:

```javascript{8,12,16}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Form onSubmit={onSubmit}>
      <label htmlFor="name">Name</label>
      <TextField name="name" validation={{ required: true }} />
      <FieldError name="name" className="error" />

      <label htmlFor="email">Email</label>
      <TextField name="email" validation={{ required: true }} />
      <FieldError name="email" className="error" />

      <label htmlFor="message">Message</label>
      <TextAreaField name="message" validation={{ required: true }} />
      <FieldError name="message" className="error" />

      <Submit>Save</Submit>
    </Form>
  </BlogLayout>
)
```

<img src="https://user-images.githubusercontent.com/300/73306040-3cf65100-41d0-11ea-99a9-9468bba82da7.png" />

Vous savez ce qui serez bien? Que le champ lui-mÃªme indique qu'il y a eu une erreur. Remarquez ici l'utilisation de l'attribut `errorClassName`:

```javascript{10,18,26}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Form onSubmit={onSubmit}>
      <label htmlFor="name">Name</label>
      <TextField
        name="name"
        validation={{ required: true }}
        errorClassName="error"
      />
      <FieldError name="name" className="error" />

      <label htmlFor="email">Email</label>
      <TextField
        name="email"
        validation={{ required: true }}
        errorClassName="error"
      />
      <FieldError name="email" className="error" />

      <label htmlFor="message">Message</label>
      <TextAreaField
        name="message"
        validation={{ required: true }}
        errorClassName="error"
      />
      <FieldError name="message" className="error" />

      <Submit>Save</Submit>
    </Form>
  </BlogLayout>
)
```

<img src="https://user-images.githubusercontent.com/300/80258907-39d8f880-8639-11ea-8816-03a11c69e8ac.png" />

Bravo! Et maintenant, appliquons ce principe Ã  l'Ã©tiquette elle-mÃªme. Pour celÃ  utilisons le composant `<Label>` fourni par Redwood. Notez comme l'attribut `for` correspond Ã  la valeur de l'attribut `name` du composant associÃ©. N'oubliez pas Ã©galement d'importer le composant:

```javascript{9,21-23,31-33,41-43}
// web/src/pages/ContactPage/ContactPage.js

import {
  Form,
  TextField,
  TextAreaField,
  Submit,
  FieldError,
  Label,
} from '@redwoodjs/forms'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  const onSubmit = (data) => {
    console.log(data)
  }

  return (
    <BlogLayout>
      <Form onSubmit={onSubmit}>
        <Label name="name" errorClassName="error">
          Name
        </Label>
        <TextField
          name="name"
          validation={{ required: true }}
          errorClassName="error"
        />
        <FieldError name="name" className="error" />

        <Label name="email" errorClassName="error">
          Email
        </Label>
        <TextField
          name="email"
          validation={{ required: true }}
          errorClassName="error"
        />
        <FieldError name="email" className="error" />

        <Label name="message" errorClassName="error">
          Message
        </Label>
        <TextAreaField
          name="message"
          validation={{ required: true }}
          errorClassName="error"
        />
        <FieldError name="message" className="error" />

        <Submit>Save</Submit>
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

<img src="https://user-images.githubusercontent.com/300/80259003-70af0e80-8639-11ea-97cf-b6b816118fbf.png" />

> En plus de `className` et `errorClassName` vous pouvez Ã©galement utiliser `style` et `errorStyle`

### Validation du Format des Champs

Nous devrions nous assurer que le champ email contient bien... un email!

```html{7-9}
// web/src/pages/ContactPage/ContactPage.js

<TextField
  name="email"
  validation={{
    required: true,
    pattern: {
      value: /[^@]+@[^.]+\..+/,
    },
  }}
  errorClassName="error"
/>
```

OK, Ã§a n'est pas la validation ultime pour un champ email, mais pour le moment faisons comme si. Modifions Ã©galement le message affichÃ© en cas d'Ã©chec de la validation:

```html{9}
// web/src/pages/ContactPage/ContactPage.js

<TextField
  name="email"
  validation={{
    required: true,
    pattern: {
      value: /[^@]+@[^.]+\..+/,
      message: 'Please enter a valid email address',
    },
  }}
  errorClassName="error"
/>
```

<img src="https://user-images.githubusercontent.com/300/80259139-bd92e500-8639-11ea-99d5-be278dc67afc.png" />

Vous avez peut-Ãªtre remarquÃ© qu'essayer d'envoyer le formulaire alors que sont prÃ©sentes des erreurs de validation n'affiche rien dans la console. C'est en rÃ©alitÃ© une bonne chose car celÃ  vous indique que le formulaire n'a pas Ã©tÃ© envoyÃ©. Corrigez la valeur des champs concernÃ©s, et tout fonctionne correctement.

> Lorsqu'un message liÃ© Ã  une erreur lors de la validation d'un champ s'affiche, il disparaÃ®t dÃ¨s que la valeur est corrigÃ©e. Ainsi l'utilisateur n'a pas Ã  devoir envoyer de nouveau le formulaire pour vÃ©rifier la validitÃ© de la saisie.

Finalement, savez-vous ce qui serait _vraiment_ sympa? Ce serait de faire en sorte que les champs soient validÃ©s dÃ¨s que l'utilisateur quitte un champ. De cette maniÃ¨re l'utilisateur n'a pas besoin de remplir l'ensemble des champs et envoyer le formulaire pour voir toutes les erreurs s'afficher. Voyons comment faire:

```html
// web/src/pages/ContactPage/ContactPage.js

<Form onSubmit={onSubmit} validation={{ mode: 'onBlur' }}>
```

Alors, qu'en pensez-vous? Quelques composants, un ou deux attributs, et vous avez devant vous un formulaire qui gÃ¨re les erreurs, valide les champs et vous envoie le contenu sous la forme d'un bel objet javascript. Merci Redwood!

> Les formulaires de Redwood sont construits Ã  partir de la librairie [React Hook Form](https://react-hook-form.com/). Celle-ci contient d'autres fonctionalitÃ©s trÃ¨s utiles que nous n'avons pas documentÃ© ici.  

Redwood a encore plus d'un tour dans son sac pour ce qui concerne les formulaires, mais nous allons garder Ã§a pour une Ã©tape ultÃ©rieure.

Avoir un formulaire de contact, c'est bien. Mais conserver les message qu'on vous envoie, c'est mieux! ProcÃ©dons maintenant Ã  la crÃ©ation de la table en base de donnÃ©es pour y enregistrer ces informations. Ce faisant nous allons crÃ©er notre premiÃ¨re mutation GraphQL!

## Enregistrer les DonnÃ©es

Ajoutons une nouvelle table Ã  notre base de donnÃ©es. Ouvrez `api/prisma/schema.prisma` et ajoutez un nouveau modÃ¨le "Contact" Ã  la suite du premier modÃ¨le "Post": 

```javascript
// api/prisma/schema.prisma

model Contact {
  id        Int @id @default(autoincrement())
  name      String
  email     String
  message   String
  createdAt DateTime @default(now())
}
```

> Pour dÃ©finir une colonne comme optionnelle (c'est Ã  dire permettre que sa valeur soit `NULL`), il suffit de suffixer le type de la donnÃ©e avec un point d'interrogation: `name String?` 

Nous crÃ©ons ensuite notre nouvelle migration:

    yarn rw db save create contact

Enfin, nous executons la migration de faÃ§on Ã  mettre Ã  jour le schÃ©ma de la base de donnÃ©es:

    yarn rw db up

Maintenant nous crÃ©eons l'interface GraphQL permettant d'accÃ©der Ã  cette nouvelle table. C'est la premiÃ¨re fois que nous utilisons cette commande `generate` nous mÃªme. (la commande `scaffold` repose Ã©galement dessus):

    yarn rw g sdl contact

De la mÃªme maniÃ¨re qu'avec la commande `scaffold`, ceci va crÃ©er deux nouveaux fichiers dans le rÃ©pertoire `api`:

1. `api/src/graphql/contacts.sdl.js`: qui dÃ©finit le schÃ©ma GraphQL
2. `api/src/services/contacts/contacts.js`: qui contient votre code mÃ©tier

Ouvrez `api/src/graphql/contacts.sdl.js` et vous verrez les types `Contact`, `CreateContactInput` et `UpdateContactInput` dÃ©jÃ  dÃ©finis pour vous. La commande `generate sdl` a analysÃ© le schÃ©ma et crÃ©Ã© un type `Contact` contenant chaque champ de la table, ainsi qu'un type `Query` avec une requÃªte `contacts` qui retourne un tableau de types `Contact`.

```javascript
// api/src/graphql/contacts.sdl.js

export const schema = gql`
  type Contact {
    id: Int!
    name: String!
    email: String!
    message: String!
    createdAt: DateTime!
  }

  type Query {
    contacts: [Contact!]!
  }

  input CreateContactInput {
    name: String!
    email: String!
    message: String!
  }

  input UpdateContactInput {
    name: String
    email: String
    message: String
  }
`
```

Que sont les "input" `CreateContactInput` et `UpdateContactInput`? Redwood suit la recommandation de GraphQL d'utiliser les [Input Types](https://graphql.org/graphql-js/mutations-and-input-types/) dans les mutations plutÃ´t que de lister tous les champs qui peuvent Ãªtre dÃ©finis. Tous les champs requis dans `schema.prisma` sont Ã©galement requis dans `CreateContactInput` (vous ne pouvez pas crÃ©er un enregistrement valide sans eux) mais rien n'est explicitement requis dans `UpdateContactInput`. En effet, vous pouvez souhaiter mettre Ã  jour un seul champ, deux champs ou tous les champs. L'alternative serait de crÃ©er des types d'entrÃ©e sÃ©parÃ©s pour chaque permutation de champs que vous souhaitez mettre Ã  jour. Nous avons estimÃ© que le fait de n'avoir qu'une seule entrÃ©e de mise Ã  jour, bien que ce ne soit peut-Ãªtre pas la maniÃ¨re absolument correcte de crÃ©er une API GraphQL, Ã©tait un bon compromis pour faciliter le dÃ©veloppement.

> Redwood suppose que votre code n'essaiera pas de dÃ©finir une valeur sur un champ nommÃ© `id` ou `createdAt` donc il les a laissÃ©s en dehors des types d'entrÃ©e, mais si votre base de donnÃ©es autorise l'un ou l'autre de ceux Ã  dÃ©finir manuellement, vous pouvez mettre Ã  jour` CreateContactInput `ou `UpdateContactInput` et les ajouter.

Puisque toutes les colonnes de la table Ã©taient dÃ©finies comme requises dans `schema.prisma`, elles sont Ã©galement dÃ©finies comme requises ici (notez le suffixe `!` sur les types de donnÃ©es)

> **important:** la syntaxe de `schema.prisma` requiert l'ajout d'un caractÃ¨re `?` lorsqu'un champ _n'est pas_ requis, tandis que la syntaxe GraphQL requiert l'ajout d'un caractÃ¨re `!` lorsqu'un champ _est_ requis.

Comme dÃ©crit dans [QuÃªte secondaire: Fonctionnement de Redwood avec les DonnÃ©es](qu-te-secondaire-fonctionnement-de-redwood-avec-les-donn-es), il n'y a pas de "resolver" dÃ©finit explicitement dans le fichier SDL. Redwood suit une convention de nommage simple: chaque champ listÃ© dans les types `Query` et `Mutation` correspondent Ã  une fonction avec un nom identique dans les fichiers `service` et `sdl` associÃ©s (`api/src/graphql/contacts.sdl.js -> api/src/services/contacts/contacts.js`) 

Dans le cas prÃ©sent, nous crÃ©eons une unique `Mutation` que nous appelons `createContact`. Nous l'ajoutons Ã  la fin de notre fichier SDL (avant le caractÃ¨re 'backtick'): 

```javascript
// api/src/graphql/contacts.sdl.js

type Mutation {
  createContact(input: CreateContactInput!): Contact
}
```

La mutation `createContact` accepte une variable unique, `input`, qui est un objet conforme Ã  ce qu'on attend pour un `CreateContactInput`, c'est Ã  dire `{ name, email, message }`.

C'est terminÃ© pour le fichier SDL, dÃ©finissons maintenant le service qui va rÃ©ellement enregistrer les donnÃ©es en base. Le service inclut une fonction `contacts` permettant de rÃ©cupÃ©rer l'ensemble des contacts depuis la base. Ajoutons-y une mutation pour pouvoir crÃ©er un nouveau contact:

```javascript{9-11}
// api/src/services/contacts/contacts.js

import { db } from 'src/lib/db'

export const contacts = () => {
  return db.contact.findMany()
}

export const createContact = ({ input }) => {
  return db.contact.create({ data: input })
}
```

GrÃ¢ce au client Prisma, il faut peu de code pour enregistrer nos donnÃ©es en base! Il s'agit d'un appel asynchrone, mais nous n'avons pas Ã  nous soucier de manipuler un objet Promise ou s'arranger avec `async/await`. La librairie Apollo le fait pour nous!

Avant d'insÃ©rer tout ceci dans notre interface utilisateur, prennons un peu de temps pour utiliser un outil bien pratique en exÃ©cutant la commande `yarn redwood dev`.

### Le Bac Ã  Sable GraphQL

Souvent, il est utile d'expÃ©rimenter notre API dans une forme un peu "brute" avant de poursuivre plus avant le dÃ©veloppement de l'interface et s'apercevoir que l'on a oubliÃ© quelque chose.

Lorsque vous avez exÃ©cutÃ© la commande `yarn redwood dev` au dÃ©but de ce didacticiel, vous avez en rÃ©alitÃ© dÃ©marrÃ© un second processus en arriÃ¨re-plan. Ouvrez donc une nouvelle page de votre navigateur Ã  cette adresse: http://localhost:8911/graphql . Il s'agit du [Bac Ã  Sable GraphQL](https://github.com/prisma-labs/graphql-playground) fournit par la librairie Prisma, une application web permettant d'interagir avec une API GraphQL: 

<img src="https://user-images.githubusercontent.com/300/70950852-9b97af00-2016-11ea-9550-b6983ce664e2.png" />

Observez en particulier l'onglet "Doc" situÃ© sur la partie droite de l'Ã©cran:

<img src="https://user-images.githubusercontent.com/300/73311311-fce89b80-41da-11ea-9a7f-2ef6b8191052.png" />

Vous y trouverez le schema complet tel que dÃ©finit dans vos fichiers SDL! L'application analyse ces dÃ©finitions et vous propose ces Ã©lÃ©ments pour vous permettre de construire vos requÃªtes. Essayez par exemple de rÃ©cupÃ©rer les ID de tous les articles en Ã©crivant votre requÃªte dans la partie gauche puis en cliquant sur le bouton "Play":

<img src="https://user-images.githubusercontent.com/300/70951466-52e0f580-2018-11ea-91d6-5a5712858781.png" />

Le bac Ã  sable GraphQL est une excellente maniÃ¨re d'expÃ©rimenter avec votre API, et comprendre pourquoi une requÃªte ne fonctionne pas comme prÃ©vue.

### CrÃ©er un Contact

Notre mutation GraphQL est prÃªte pour la partie backend, tout ce qu'il reste Ã  faire c'est l'invoquer depuis la partie frontend. Tout ce qui Ã  trait Ã  notre formulaire se trouve dans `ContactPage`, c'est donc l'endroit logique pour y mettre l'appel Ã  notre nouvelle mutation. D'abord nous dÃ©finissons cette mutation comme une constante que nous appellerons plus tard (ceci peut Ãªtre dÃ©fini en dehors du composant lui-mÃªme, juste aprÃ¨s les lignes d'imports):

```javascript
// web/src/pages/ContactPage/ContactPage.js

const CREATE_CONTACT = gql`
  mutation CreateContactMutation($input: CreateContactInput!) {
    createContact(input: $input) {
      id
    }
  }
`
```

Nous rÃ©fÃ©renÃ§ons ainsi la mutation `createContact` dÃ©finie auparavant dans le fichier SDL des contacts, tout en lui passant en argument un objet `input` contenant la valeur des champs `name`, `email` et `message`.

AprÃ¨s quoi, nous appelons le 'hook' `useMutation` fourni par Appolo, ce qui nous permet d'exÃ©cuter la mutation lorsque le moment est venu (n'oubliez pas les imports comme Ã  chaque fois):

```javascript{11,15}
// web/src/pages/ContactPage/ContactPage.js

import {
  Form,
  TextField,
  TextAreaField,
  Submit,
  FieldError,
  Label,
} from '@redwoodjs/forms'
import { useMutation } from '@redwoodjs/web'
import BlogLayout from 'src/layouts/BlogLayout'

const ContactPage = () => {
  const [create] = useMutation(CREATE_CONTACT)

  const onSubmit = (data) => {
    console.log(data)
  }

  return (...)
}
```
`create` est une fonction qui invoque la mutation et prend en paramÃ¨tre un objet contenant un clef `variables`. Cette derniÃ¨re contient Ã  son tour une clef `input`. Par exemple, nous pourrions l'appeler Ã©galement de cette maniÃ¨re:

```javascript
create({
  variables: {
    input: {
      name: 'Rob',
      email: 'rob@redwoodjs.com',
      message: 'I love Redwood!',
    },
  },
})
```

Si votre mÃ©Ã©moire est bonne, vous vous souvenez sans doute que la balise `<Form>` nous donne accÃ¨s Ã  l'ensemble des champs du formulaire avec un objet bien pratique dans lequel chaque clef se trouve Ãªtre le nom du champ. CelÃ  signifie donc que l'objet `data`que nous recevons dans `onSubmit` est dÃ©jÃ  dans le format adaptÃ© pour `input`!  

Maintenant nous pouvons mettre Ã  jour la fonction `onSubmit` pour invoquer la mutation avec les donnÃ©es qu'elle reÃ§oit:

```javascript{7}
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = () => {
  const [create] = useMutation(CREATE_CONTACT)

  const onSubmit = (data) => {
    create({ variables: { input: data }})
    console.log(data)
  }

  return (...)
}
```

Essayez-donc de remplir le formulaire et de l'envoyer. Vous devriez obtenir un nouveau contact en base de donnÃ©es! Vous pouvez vÃ©rifier ceci avec l'outil bac Ã  sable de GraphQL:

![image](https://user-images.githubusercontent.com/300/76250632-ed5d6900-6202-11ea-94ce-bd88e3a11ade.png)

### AmÃ©liorer le formulaire de contact

Notre formulaire de contact fonctionne, mais il subsiste quelques problÃ¨mes:

- Cliquer sur le bouton d'enregistrement plusieurs fois Ã  pour consÃ©quence d'envoyer le formulaire Ã©galement plusieurs fois
- L'utilisateur ne sait pas si l'envoi a bien Ã©tÃ© pris en compte
- Si une erreur devait se produire cÃ´tÃ© serveur, nous n'avons aucun moyen d'en informer l'utilisateur

Essayons d'y apporter une solution.

Le 'hook' `useMutation` retourne quelques autres Ã©lÃ©ments en plus de la fonction permettant de l'invoquer. Nous pouvons dÃ©structurer ceux-ci (`loading` et `error`) de la faÃ§on suivante:

```javascript{4}
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = () => {
  const [create, { loading, error }] = useMutation(CREATE_CONTACT)

  const onSubmit = (data) => {
    create({ variables: { input: data } })
    console.log(data)
  }

  return (...)
}
```

Ce faisant, nous savons si un appel Ã  la base est toujours en cours en utilisant la valeur de `loading`. Une faÃ§on simple de rÃ©soudre le problÃ¨me des soumissions multiples du mÃªme formulaire est de rendre inactif le bouton d'envoi tant que la rÃ©ponse n'a pas Ã©tÃ© reÃ§ue. Nous pouvons faire celÃ  en liant l'attribut `disabled` du bouton "save" Ã  la valeur contanue dans `loading`:

```javascript{5}
// web/src/pages/ContactPage/ContactPage.js

return (
  // ...
  <Submit disabled={loading}>Save</Submit>
  // ...
)
```

Il peut Ãªtre difficile de voir une diffÃ©rence en phase de dÃ©veloppement car l'envoi est trÃ¨s rapide. Mais vous pouvez nÃ©anmoins activer un outil bien pratique dans le navigateur Chrome afin de simuler une connection lente:

<img src="https://user-images.githubusercontent.com/300/71037869-6dc56f80-20d5-11ea-8b26-3dadb8a1ed86.png" />

Vous verrez alors que le bouton "Save" devient inactif pendant une seconde ou deux en attendant la rÃ©ponse.

Maintenant, utilisons le systÃ¨me dit de `Flash` proposÃ© par Redwood afin d'informer l'utilisateur que son envoi Ã  bien Ã©tÃ© traitÃ©. `useMutation` accepte un second paramÃ¨tre optionnel contenant des options. Une de ces options est une fonction callback appelÃ©e `onCompleted` qui sera invoquÃ©e lorsque la mutation sera achevÃ©e avec succÃ¨s. Nous allons donc utiliser cette fonction pour ajouter un message qui sera affichÃ© par un composant `Flash`. Ajoutez donc le composant `Flash` a votre page et utilisez sa propriÃ©tÃ© `timeout` pour dÃ©finir le temps d'affichage. (Vous pouvez lire la documentation Ã  propos du systÃ¨me de Flash proposÃ© par Redwood [ici](https://redwoodjs.com/docs/flash-messaging-bus))

```javascript{4,10,13-17,24}
// web/src/pages/ContactPage/ContactPage.js

// ...
import { Flash, useFlash, useMutation } from '@redwoodjs/web'
import BlogLayout from 'src/layouts/BlogLayout'

// ...

const ContactPage = () => {
  const { addMessage } = useFlash()

  const [create, { loading, error }] = useMutation(CREATE_CONTACT, {
    onCompleted: () => {
      addMessage('Thank you for your submission!', {
        style: { backgroundColor: 'green', color: 'white', padding: '1rem' }
      })
    },
  })

  // ...

  return (
    <BlogLayout>
      <Flash timeout={2000} />
      // ...
```

### Afficher les erreurs serveur

Nous allons maintenant informer l'utilisateur des Ã©ventuelles erreurs cÃ´tÃ© serveur. Jusqu'ici nous n'avons notifiÃ© les utilisateurs quie des erreurs _cÃ´tÃ© client_ lorsqu'un champ Ã©tait manquant ou formatÃ© incorrectement. Mais si nous avons Ã©galement des contraintes cÃ´tÃ© serveur que le composant `<Form>` ignore, nous devons tout de mÃªme pouvoir en informer l'utilisateur.

Ainsi, nous avons une validateur de l'email cÃ´tÃ© client, mais tout bon dÃ©veloppeur web sait qu'il ne faut [_jamais faire confiance au client_](https://www.codebyamir.com/blog/never-trust-data-from-the-browser). Ajoutons une validation de l'email cÃ´tÃ© serveur de faÃ§on Ã  Ãªtre certain qu'aucune donnÃ©e erronÃ©e ne soit ajoutÃ©e dans la base, et ce mÃªme si un utilisateur parvenait Ã  contourner le fonctionnement de l'application cÃ´tÃ© client.

> Pourquoi n'avons-nous pas besoin de validation cÃ´tÃ© serveur pour s'assurer que les champs name, email et message sont bien remplis? Car la base de donnÃ©es le fait pour nous. Vous rappellez-vous `String!` dans notre fichier SDL? CelÃ  ajoute une contrainte en base de donnÃ©es de telle faÃ§on que ce champ ne puisse Ãªtre `null`. Une valeur `null` serait rejetÃ©e par la base et GraphQL renverrait une erreur Ã  la partie client. 
>
> Cependant, il n'existe pas de type `Email!`, raison pour laquelle nous devons assurer la validation nous mÃªme 

Nous avons dÃ©jÃ  parlÃ© de code mÃ©tier et du fait que ce type de code a vocation Ã  se trouver dans nos fichiers services. Ceci en est un exemple parfait. Ajoutons une fonction `validate` Ã  notre service `contacts`:

```javascript{3,7-15,22}
// api/src/services/contacts/contacts.js

import { UserInputError } from '@redwoodjs/api'

import { db } from 'src/lib/db'

const validate = (input) => {
  if (input.email && !input.email.match(/[^@]+@[^.]+\..+/)) {
    throw new UserInputError("Can't create new contact", {
      messages: {
        email: ['is not formatted like an email address'],
      },
    })
  }
}

export const contacts = () => {
  return db.contact.findMany()
}

export const createContact = ({ input }) => {
  validate(input)
  return db.contact.create({ data: input })
}
```

Ainsi, lorsque `createContact` est invoquÃ©e, la fonction commence par valider le contenu des champs du formulaire. Puis, et seulement s'il n'y a aucune erreur, l'enregistrement sera crÃ©Ã© en base de donnÃ©es.

Nous capturons dÃ©jÃ  toutes les erreurs dans la constante `error` que nous obtenons grÃ¢ce au 'hook' `useMutation`. C'est pourquoi nous avons la possibilitÃ© d'afficher ces erreurs sur la page, par exemple au dessus du formulaire:

```html{4-9}
// web/src/pages/ContactPage/ContactPage.js

<Form onSubmit={onSubmit} validation={{ mode: 'onBlur' }}>
  {error && (
    <div style={{ color: 'red' }}>
      {"We couldn't send your message: "}
      {error.message}
    </div>
  )}
  // ...
```

> Si vous avez besoin de manipuler l'objet contenant les erreurs, vous pouvez procÃ©der ainsi:
>
> ```javascript{3-8}
> // web/src/pages/ContactPage/ContactPage.js
> const onSubmit = async (data) => {
>   try {
>     await create({ variables: { input: data } })
>     console.log(data)
>   } catch (error) {
>     console.log(error)
>   }
> }
> ```

Afin de tester ceci, provoquons une erreur en retirant temporairement la validation cÃ´tÃ© client de l'adresse email:

```html
// web/src/pages/ContactPage/ContactPage.js

<TextField
  name="email"
  validation={{
    required: true,
  }}
  errorClassName="error"
/>
```

Maintenant, essayons de remplir le formulaire avec un adresse invalide:

<img src="https://user-images.githubusercontent.com/300/80259406-5aee1900-863a-11ea-9b82-def3a4f3e162.png" />

CelÃ  fonctionne, mÃªme si l'affichage reste Ã  amÃ©liorer. Voir apparaÃ®tre une erreur GraphQL n'est pas idÃ©al. Il serait plus sympa de faire en sorte que ce soit le champ concernÃ© qui soit marquÃ© d'une erreur...

Vous rapellez-vous lorsque nous avons dit que `<Form>` avait plus d'un tour dans son sac? Voyons donc Ã§a!

Supprimez l'affichage de l'erreur tel que nous venons de l'ajouter (`{ error && ...}`) , et remplacez-le avec `<FormError>` tout en passant en argument la constante `error` que nous rÃ©cupÃ©rons depuis `useMutation`. Ajoutez Ã©galement quelques Ã©Ã©lÃ©ments de style Ã  `wrapperStyle`, sans oublier les `import` associÃ©s.

```javascript{10,18-22}
// web/src/pages/ContactPage/ContactPage.js

import {
  Form,
  TextField,
  TextAreaField,
  Submit,
  FieldError,
  Label,
  FormError,
} from '@redwoodjs/forms'
import { Flash, useFlash, useMutation } from '@redwoodjs/web'
// ...

return (
  <BlogLayout>
    <Flash timeout={1000}>
    <Form onSubmit={onSubmit} validation={{ mode: 'onBlur' }} error={error}>
      <FormError
        error={error}
        wrapperStyle={{ color: 'red', backgroundColor: 'lavenderblush' }}
      />

      //...
)
```

DÃ©sormais, l'envoi du formulaire avec une adresse invalide donne ceci:

<img src="https://user-images.githubusercontent.com/300/80259553-c46e2780-863a-11ea-9441-54a9112b9ce5.png" />

Nous obtenons un message d'erreur en haut du formulaire _et_ les champs concernÃ©s sont mis en avant! Le message en haut du formulaire peut apparaÃ®tre un peu lourd pour un si petit formulaire, mais vous contaterez son utilitÃ© lorsque vous construirez des formulaires de plusieurs pages; de cette faÃ§on l'utilisateur peut voir immÃ©Ã©diatement ce qui ne fonctionne pas sans avoir Ã  parcourir l'ensemble du formulaire. Si vous ne souhaitez pas utiliser cet affichage, il vous suffit de supprimer `<FormError>`, les champs seront toujours mis en avant.

> `<FormError>` a plusieurs options pour adapter le style d'affichage
>
> - `wrapperStyle` / `wrapperClassName`: le conteneur pour l'ensemble du message
> - `titleStyle` / `titleClassName`: le titre "Can't create new contact"
> - `listStyle` / `listClassName`: le `<ul>` qui contient la liste des erreurs
> - `listItemStyle` / `listItemClassName`: chaque `<li>` contenant chaque erreur

### One more thing...

Puisque nous ne redirigeons pas l'utilisateur une fois le formulaire envoyÃ©, nous devrions au moins remettre le formulaire Ã  zÃ©ro. Pour celÃ  nous devons utiliser la fonction `reset()` proposÃ©e par `react-hook-form`, mais nous n'y avons pas accÃ¨s compte tenu de la maniÃ¨re dont nous utilisons `<Form>`.

`react-hook-form` possÃ¨de un 'hook' appelÃ© `useForm()` qui est en principe invoquÃ©Ã© pour nous Ã  l'intÃ©rieur de `<Form>`. De faÃ§on Ã  rÃ©initialiser le formulaire nous devons invoquer ce 'hook' manuellement. Voici comment faire:

CommenÃ§ons par importer `useForm`:

```javascript
// web/src/pages/ContactPage/ContactPage.js

import { useForm } from 'react-hook-form'
```

Puis invoquons ce 'hook' dans notre composant:

```javascript{4}
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = () => {
  const formMethods = useForm()
  //...
```

Enfin, donnons pour instruction explicite Ã  `<Form>` d'utiliser `formMethods`, au lieu de le laisser le faire lui-mÃªme:

```javascript{10}
// web/src/pages/ContactPage/ContactPage.js

return (
  <BlogLayout>
    <Flash timeout={1000}>
    <Form
      onSubmit={onSubmit}
      validation={{ mode: 'onBlur' }}
      error={error}
      formMethods={formMethods}
    >
    // ...
```

Maintenant nous pouvons invoquer manuellement `reset()` depuis `formMethods()` juste aprÃ¨s que le message de confirmation soit affichÃ©:

```javascript
// web/src/pages/ContactPage/ContactPage.js

const [create, { loading, error }] = useMutation(CREATE_CONTACT, {
  onCompleted: () => {
    // addMessage...
    formMethods.reset()
  },
})
```

<img alt="Capture Ã©cran du formulaire de Contact avec message de confirmation Flash" src="https://user-images.githubusercontent.com/44448047/93649232-1be9a700-f9d1-11ea-821c-7a69c626f50c.png">

> Vous pouvez maintenant rÃ©activer la validation email cÃ´tÃ© client sur le `<TextField>`, tout en conservant la validation cÃ´tÃ© serveur.

Voici le contenu final de la page `ContactPage.js`: 

```javascript
import {
  Form,
  TextField,
  TextAreaField,
  Submit,
  FieldError,
  Label,
  FormError,
} from '@redwoodjs/forms'
import { Flash, useFlash, useMutation } from '@redwoodjs/web'
import { useForm } from 'react-hook-form'
import BlogLayout from 'src/layouts/BlogLayout'

const CREATE_CONTACT = gql`
  mutation CreateContactMutation($input: CreateContactInput!) {
    createContact(input: $input) {
      id
    }
  }
`

const ContactPage = () => {
  const formMethods = useForm()
  const { addMessage } = useFlash()

  const [create, { loading, error }] = useMutation(CREATE_CONTACT, {
    onCompleted: () => {
      addMessage('Thank you for your submission!', {
        style: { backgroundColor: 'green', color: 'white', padding: '1rem' }
      })
      formMethods.reset()
    },
  })

  const onSubmit = (data) => {
    create({ variables: { input: data } })
    console.log(data)
  }

  return (
    <BlogLayout>
      <Flash timeout={1000} />
      <Form
        onSubmit={onSubmit}
        validation={{ mode: 'onBlur' }}
        error={error}
        formMethods={formMethods}
      >
        <FormError
          error={error}
          wrapperStyle={{ color: 'red', backgroundColor: 'lavenderblush' }}
        />
        <Label name="name" errorClassName="error">
          Name
        </Label>
        <TextField
          name="name"
          validation={{ required: true }}
          errorClassName="error"
        />
        <FieldError name="name" className="error" />

        <Label name="name" errorClassName="error">
          Email
        </Label>
        <TextField
          name="email"
          validation={{
            required: true,
          }}
          errorClassName="error"
        />
        <FieldError name="email" className="error" />

        <Label name="name" errorClassName="error">
          Message
        </Label>
        <TextAreaField
          name="message"
          validation={{ required: true }}
          errorClassName="error"
        />
        <FieldError name="message" className="error" />

        <Submit disabled={loading}>Save</Submit>
      </Form>
    </BlogLayout>
  )
}

export default ContactPage
```

C'est terminÃ©! [React Hook Form](https://react-hook-form.com/) propose pas mal de fonctionalitÃ©s que `<Form>` n'expose pas. Lorsque vous souhaitez les utiliser, appelez juste le 'hook' `useForm()` vous-mÃªme, en vous assurant de bien passer en argument l'objet retournÃ© (`formMethods`) comme propriÃ©tÃ© de `<Form>` de faÃ§on Ã  ce que la validation et les autres fonctionalitÃ©s puissent continuer Ã  fonctionner. 

> Vous avez peut-Ãªtre remarquÃ© que la validation onBlur a cessÃ© de fonctionner lorsque vous avez commencÃ© Ã  appeler `userForm()` par vous-mÃªme. Ceci s'explique car Redwood invoque `userForm()` et lui passe automatiquement en argument ce que vous avez passÃ© Ã  `<Form>`. Puisque Redwood n'appelle plus automatiquement `useForm()` Ã  votre place, vous devez de faire manuellement:
>
> ```javascript
> const formMethods = useForm({ mode: 'onBlur' })
> ```

La partie publique du site a bon aspect. Que faire maintenant de la partie administration qui nous permet de crÃ©er et Ã©diter les articles? Nous devrions la dÃ©placer dans une partie rÃ©servÃ©e et la placer derriÃ¨re un login, de faÃ§on Ã  ce des utilisateurs mal intentionnÃ©s ne puissent pas crÃ©er en chaÃ®ne, par exemple, des publicitÃ©s pour l'achat de mÃ©dicaments en ligne...

## Administration

Having the admin screens at `/admin` is a reasonable thing to do. Let's update the routes to make that happen by updating the four routes starting with `/posts` to start with `/admin/posts` instead:

```html
// web/src/Routes.js

<Route path="/admin/posts/new" page={NewPostPage} name="newPost" />
<Route path="/admin/posts/{id:Int}/edit" page={EditPostPage} name="editPost" />
<Route path="/admin/posts/{id:Int}" page={PostPage} name="post" />
<Route path="/admin/posts" page={PostsPage} name="posts" />
```

Head to http://localhost:8910/admin/posts and our generated scaffold page should come up. Thanks to named routes we don't have to update any of the `<Link>`s that were generated by the scaffolds since the `name`s of the pages didn't change!

> On the last page we said we were going to set up an admin section **and** put it
> behind a login. So far, all we've done is updated the routes. Don't worry, we
> haven't forgotten! We will be setting up authentication in a [future step](/tutorial/authentication).

How about getting this thing out into the real world?

## Deployment

Part 4 of the video tutorial picks up here:

<div class="relative pb-9/16">
  <iframe class="absolute inset-0 w-full h-full" src="https://www.youtube.com/embed/UpD3HyuZkvY?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture; modestbranding; showinfo=0" allowfullscreen></iframe>
</div>

The whole reason we started building Redwood was to make full-stack web apps easier to build and deploy on the Jamstack. You've seen what building a Redwood app is like, how about we try deploying one?

We've only got one change to make to the codebase to get it ready for deployment and we've got a generator to do it for us:

```terminal
yarn rw g deploy netlify
```

This creates a file at `/netlify.toml` which contains the commands and file paths that Netlify needs to know about to build a Redwood app.

Before we continue, make sure your app is fully committed and pushed to GitHub, GitLab, or Bitbucket. We're going to link Netlify directly to our git repo so that a simple push to `main` will re-deploy our site. If you haven't worked on the Jamstack yet you're in for a pleasant surprise!

> **NOTE:** Git initializes with `master`. Don't know how to rename `master` to `main`? If you're pushing to GitHub, you can follow these steps:
>
> ```plaintext{4,6}
> git init
> git add .
> git commit -m 'First commit'
> git branch -m main
> git remote add origin ...
> git push -u origin main
> ```

### Vercel (alternative deploy target)

Redwood officially supports multiple hosting providers (with even more on the way). Although this Tutorial continues with a focus on Netlify deployment and authentication with Netlify Identity, you can deploy to [Vercel](https://vercel.com/redwoodjs-core) instead. To do this, first complete "The Database" section below, but then use this [Vercel deploy walkthrough](https://redwoodjs.com/docs/deploy#redwood-deploy-configuration) in place of the following "Netlify" instructions. **Note**: Netlify Identity, used in upcoming "Authentication" section, wonâ€™t work on the Vercel platform.

### The Database

We'll need a database somewhere on the internet to store our data. We've been using SQLite locally, but that's a file-based store meant for single-user. SQLite isn't really suited for the kind of connection and concurrency requirements a production website will require. For this part of this tutorial, we will use Postgres. (Prisma currently supports SQLite, Postgres and MySQL.) Don't worry if you aren't familiar with Postgres, Prisma will do all the heavy lifting. We just need to get a database available to the outside world so it can be accessed by our app.

First we'll let Prisma know that we intend to use Postgres in addition to SQLite so it will build client libraries for both. Update the `provider` entry in `schema.prisma`:

```javascript
provider = ["sqlite", "postgresql"]
```

If you'd like to develop locally with Postgres, see the
[Local Postgres Setup](/docs/local-postgres-setup) guide.

> For now, you need to set up your own database, but we are working with various infrastructure providers to make this process simpler and more Jamstacky. Stay tuned for improvements in that regard!

There are several hosting providers where you can quickly start up a Postgres instance:

- [Heroku](https://www.heroku.com/postgres)
- [Digital Ocean](https://www.digitalocean.com/products/managed-databases)
- [AWS](https://aws.amazon.com/rds/postgresql/)

We're going to go with Heroku for now because it's a) free and b) easier to get started from scratch than AWS.

Head over to [Heroku](https://signup.heroku.com/) and create an account or log in. Then click that **Create a new app** button:

<img alt="Screen Shot 2020-02-03 at 3 22 36 PM" src="https://user-images.githubusercontent.com/300/73703866-438c3900-46a6-11ea-9a90-bdab2fed8bff.png">

Give it a name like "redwoodblog" if it's available. Go to the **Resources** tab and then click **Find more add-ons** in the **Add-ons** section:

<img alt="Screen Shot 2020-02-03 at 3 23 25 PM" src="https://user-images.githubusercontent.com/300/73703877-4e46ce00-46a6-11ea-87c0-079346f4d9b3.png">

And scroll down to **Heroku Postgres**:

<img alt="Screen Shot 2020-02-03 at 3 23 48 PM" src="https://user-images.githubusercontent.com/300/73703883-556ddc00-46a6-11ea-8777-ee27d2202e0e.png">

Click that and then on the detail page that comes up click the **Install Heroku Postgres** button that top right. On the next screen tell it you want to connect it to the app you just created, then click **Provision add-on**:

<img alt="Screen Shot 2020-02-03 at 3 24 15 PM" src="https://user-images.githubusercontent.com/300/73703930-64548e80-46a6-11ea-9f1b-e06a183834f4.png">

You'll be returned to your app's detail page. You should be on the **Resources** tab and see the Heroku Postgres add-on ready to go:

<img alt="Screen Shot 2020-02-03 at 3 24 43 PM" src="https://user-images.githubusercontent.com/300/73703951-6ae30600-46a6-11ea-8d9b-a900b7af2ac5.png">

Click the **Heroku Postgres** link to get to the detail page, then the **Settings** tab and finally the **View Credentials...** button. We did all the steps above so that we could copy the URI listed at the bottom:

<img alt="Screen Shot 2020-02-03 at 3 25 31 PM" src="https://user-images.githubusercontent.com/300/73703956-70405080-46a6-11ea-81f2-bed99ca4c4cc.png">

It will be really long and scroll off the right side of the page so make sure you copy the whole thing!

### Netlify

Now we're going to [create a Netlify account](https://app.netlify.com/signup) if you don't have one already. Once you've signed up and verified your email done just click the **New site from Git** button at the upper right:

<img src="https://user-images.githubusercontent.com/300/73697486-85f84a80-4693-11ea-922f-0f134a3e9031.png" />

Now just authorize Netlify to connect to your git hosting provider and find your repo. When the deploy settings come up you can leave everything as the defaults and click **Deploy site**.

Netlify will start building your app (click the **Deploying your site** link to watch the logs) and it will say "Site is live", but nothing will work. Why? We haven't told it where to find our database yet.

Go back to the main site page and then to **Settings** at the top, and then **Build & Deploy** > **Environment**. Click **Edit Variables** and this is where we'll paste the database connection URI we got from Heroku (note the **Key** is "DATABASE_URL"). After pasting the value, append `?connection_limit=1` to the end. The URI will have the following format: `postgres://<user>:<pass>@<url>/<db>?connection_limit=1`.

![Adding ENV var](https://user-images.githubusercontent.com/300/83188236-3e834780-a0e4-11ea-8cfa-790c2e335a92.png)

> When configuring a database, you'll want to append `?connection_limit=1` to the URI. This is [recommended by Prisma](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/deployment#recommended-connection-limit) when working with relational databases in a Serverless context.

Make sure to click the **Save** button. Now go over to the **Deploys** tab in the top nav and open the **Trigger deploy** dropdown on the right, then finally choose **Deploy site**:

![Trigger deploy](https://user-images.githubusercontent.com/300/83187760-835aae80-a0e3-11ea-9733-ff54969bba1f.png)

With a little luck (and SCIENCE) it will complete successfully! You can click the **Preview** button at the top of the deploy log page, or go back and click the URL of your Netlify site towards the top:

![Netlify URL](https://user-images.githubusercontent.com/300/83187909-bef57880-a0e3-11ea-97dc-e557248acd3a.png)

Did it work? If you see "Empty" under the About and Contact links then it did! Yay! You're seeing "Empty" because you don't have any posts in your brand new production database so head to `/admin/posts` and create a couple, then go back to the homepage to see them.

> If you view a deploy via the **Preview** button notice that the URL contains a hash of the latest commit. Netlify will create one of these for every push to `main` but will only ever show this exact commit, so if you deploy again and refresh you won't see any changes. The real URL for your site (the one you get from your site's homepage in Netlify) will show the latest deploy. See [branch deploys](#branch-deploys) below for more info.

If the deploy failed, check the log output in Netlify and see if you can make sense of the error. If the deploy was successful but the site doesn't come up, try opening the web inspector and look for errors. Are you sure you pasted the entire Postgres connection string correctly? If you're really, really stuck head over to the [Redwood Community](https://community.redwoodjs.com) and ask for help.

### Branch Deploys

Another neat feature of Netlify is _Branch Deploys_. When you create a branch and push it up to your repo, Netlify will build that branch at a unique URL so that you can test your changes, leaving the main site alone. Once your branch is merged to `main` then a deploy at your main site will run and your changes will show to the world. To enable Branch Deploys go to **Settings** > **Continuous Deployment** and under the **Deploy contexts** section click **Edit settings** and change **Branch deploys** to "All". You can also enable _Deploy previews_ which will create them for any pull requests against your repo.

![Netlify settings screenshot](https://user-images.githubusercontent.com/30793/90886476-c1016780-e3b2-11ea-851a-3014257484fd.png)

> You also have the ability to "lock" the `main` branch so that deploys do not automatically occur on every pushâ€”you need to manually tell Netlify to deploy the latest, either by going to the site or using the [Netlify CLI](https://cli.netlify.com/).

### A Note About DB Connections

In this tutorial, your lambda functions will be connecting directly to the Postgres database. Because Postgres has a limited number of concurrent connections it will accept, this does not scale very well. The proper solution is to put a connection pooling service in front of Postgres and connect to that from your lambda functions. To learn how to do that, see the [Connection Pooling](/docs/connection-pooling) guide.

We are working on making this process much easier, but keep it in mind before you deploy a Redwood app to production and announce it to the world.

## Authentication

"Authentication" is a blanket term for all of the stuff that goes into making sure that a user, often identified with an email address and password, is allowed to access something. Authentication can be [famously fickle](https://www.rdegges.com/2017/authentication-still-sucks/) to do right both from a technical standpoint and developer happiness standpoint.

But you know Redwood has your back! Login isn't something we have to write from scratchâ€”it's a solved problem and is one less thing we should have to worry about. Today Redwood includes integrations to:

- [Auth0](https://auth0.com/)
- [Netlify Identity](https://docs.netlify.com/visitor-access/identity/)

We're going to demo a Netlify Identity integration in this tutorial since we're already deployed there and it's very easy to add to a Netlify site.

> There are two terms which contain a lot of letters, starting with an "A" and ending in "ation" (which means you could rhyme them if you wanted to) that become involved in most discussions about login:
>
> * Authentication
> * Authorization
>
> Here is how Redwood uses these terms:
>
> * **Authentication** deals with determining whether someone is who they say they are, generally by "logging in" with an email and password, or a third party OAuth provider like Google.
> * **Authorization** is whether a user (who has usually already been authenticated) is allowed to do something they want to do. This generally involves some combination of roles and permission checking before allowing access to a URL or feature of your site.
>
> This section of the tutorial focuses on **Authentication** only. We're currently working on integrating a simple and flexible role-based authorization system and once we release it we'll update the tutorial to include a walkthrough!

### Netlify Identity Setup

Assuming you've been following along, you already have a Netlify account and a site set up. If you'd be so kind, head to the **Identity** tab and click the **Enable Identity** button:

![Netlify Identity screenshot](https://user-images.githubusercontent.com/300/82271191-f5850380-992b-11ea-8061-cb5f601fa50f.png)

When the screen refreshes click the **Invite users** button and enter a real email address (they're going to send a confirmation link to it):

![Netlify invite user screenshot](https://user-images.githubusercontent.com/300/82271302-439a0700-992c-11ea-9d6d-004adef3a385.png)

We'll need to get that email confirmation link soon, but for now let's set up our app for authentication.

### Authentication Generation

There are a couple of places we need to add some code for authentication and lucky for us Redwood can do it automatically with a generator:

```terminal
yarn rw g auth netlify
```

The generator adds one file and modifies a couple others.

> Don't see any changes?
>
> For this to work you must be on version `0.7.0` or greater of Redwood. If you
> don't see any file changes, try
> [upgrading](/reference/command-line-interface#upgrade) your Redwood packages
> with `yarn rw upgrade`.

Take a look at the newly created `api/src/lib/auth.js` (usage comments omitted):

```javascript
// api/src/lib/auth.js

import { AuthenticationError } from '@redwoodjs/api'

export const getCurrentUser = async (decoded, { token, type }) => {
  return decoded
}

export const requireAuth = () => {
  if (!context.currentUser) {
    throw new AuthenticationError("You don't have permission to do that.")
  }
}
```

By default the authentication system will return only the data that the third-party auth handler knows about (that's what's inside the `jwt` object above). For Netlify Identity that's an email address, an optional name and optional array of roles. Usually you'll have your own concept of a user in your local database. You can modify `getCurrentUser` to return that user, rather than the details that the auth system stores. The comments at the top of the file give one example of how you could look up a user based on their email address. We also provide a simple implementation for requiring that a user be authenticated when trying to access a service: `requireAuth()`. It will throw an error that GraphQL knows what to do with if a non-authenticated person tries to get to something they shouldn't.

The files that were modified by the generator are:

* `web/src/index.js`â€”wraps the router in `<AuthProvider>` which makes the routes themselves authentication aware, and gives us access to a `useAuth()` hook that returns several functions for logging users in and out, checking their current logged-inness, and more.
* `api/src/functions/graphql.js`â€”makes `currentUser` available to the api side so that you can check whether a user is allowed to do something on the backend. If you add an implementation to `getCurrentUser()` in `api/src/lib/auth.js` then that is what will be returned by `currentUser`, otherwise it will return just the details the auth system has for the user. If they're not logged in at all then `currentUser` will be `null`.

We'll hook up both the web and api sides below to make sure a user is only doing things they're allowed to do.

### API Authentication

First let's lock down the API so we can be sure that only authorized users can create, update and delete a Post. Open up the Post service and let's add a check:

```javascript{4,17,24,32}
// api/src/services/posts/posts.js

import { db } from 'src/lib/db'
import { requireAuth } from 'src/lib/auth'

export const posts = () => {
  return db.post.findMany()
}

export const post = ({ id }) => {
  return db.post.findOne({
    where: { id },
  })
}

export const createPost = ({ input }) => {
  requireAuth()
  return db.post.create({
    data: input,
  })
}

export const updatePost = ({ id, input }) => {
  requireAuth()
  return db.post.update({
    data: input,
    where: { id },
  })
}

export const deletePost = ({ id }) => {
  requireAuth()
  return db.post.delete({
    where: { id },
  })
}

export const Post = {
  user: (_obj, { root }) => db.post.findOne({ where: { id: root.id } }).user(),
}
```

Now try creating, editing or deleting a post from our admin pages. Nothing happens! Should we show some kind of friendly error message? In this case, probably notâ€”we're going to lockdown the admin pages altogether so they won't be accessible by a browser. The only way someone would be able to trigger these errors in the API is if they tried to access the GraphQL endpoint directly, without going through our UI. The API is already returning an error message (open the Web Inspector in your browser and try that create/edit/delete again) so we are covered.

> Note that we're putting the authentication checks in the service and not checking in the GraphQL interface (in the SDL files).
>
> Redwood created the concept of **services** as containers for your business logic which can be used by other parts of your application besides the GraphQL API. By putting authentication checks here you can be sure that any other code that tries to create/update/delete a post will fall under the same authentication checks. In fact, Apollo (the GraphQL library Redwood uses) [agrees with us](https://www.apollographql.com/docs/apollo-server/security/authentication/#authorization-in-data-models)!

### Web Authentication

Now we'll restrict access to the admin pages completely unless you're logged in. The first step will be to denote which routes will require that you be logged in. Enter the `<Private>` tag:

```javascript{3,12,16}
// web/src/Routes.js

import { Router, Route, Private } from '@redwoodjs/router'

const Routes = () => {
  return (
    <Router>
      <Route path="/contact" page={ContactPage} name="contact" />
      <Route path="/about" page={AboutPage} name="about" />
      <Route path="/" page={HomePage} name="home" />
      <Route path="/blog-post/{id:Int}" page={BlogPostPage} name="blogPost" />
      <Private unauthenticated="home">
        <Route path="/admin/posts/new" page={NewPostPage} name="newPost" />
        <Route path="/admin/posts/{id:Int}/edit" page={EditPostPage} name="editPost" />
        <Route path="/admin/posts/{id:Int}" page={PostPage} name="post" />
        <Route path="/admin/posts" page={PostsPage} name="posts" />
      </Private>
      <Route notfound page={NotFoundPage} />
    </Router>
  )
}

export default Routes
```

Surround the routes you want to be behind authentication and optionally add the `unauthenticated` attribute that lists the name of another route to redirect to if the user is not logged in. In this case we'll go back to the homepage.

Try that in your browser. If you hit http://localhost:8910/admin/posts you should immediately go back to the homepage.

Now all that's left to do is let the user actually log in! If you've built authentication before then you know this part is usually a drag, but Redwood makes it a walk in the park. Most of the plumbing was handled by the auth generator, so we get to focus on the parts the user actually sees. First, let's add a **Login** link that will trigger a modal from the [Netlify Identity widget](https://github.com/netlify/netlify-identity-widget). Let's assume we want this on all of the public pages, so we'll put it in the `BlogLayout`:

```javascript{4,7,22-26}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'
import { useAuth } from '@redwoodjs/auth'

const BlogLayout = ({ children }) => {
  const { logIn } = useAuth()

  return (
    <div>
      <h1>
        <Link to={routes.home()}>Redwood Blog</Link>
      </h1>
      <nav>
        <ul>
          <li>
            <Link to={routes.about()}>About</Link>
          </li>
          <li>
            <Link to={routes.contact()}>Contact</Link>
          </li>
          <li>
            <a href="#" onClick={logIn}>
              Log In
            </a>
          </li>
        </ul>
      </nav>
      <main>{children}</main>
    </div>
  )
}

export default BlogLayout
```

Try clicking the login link:

![Netlify Identity Widget modal](https://user-images.githubusercontent.com/300/82387730-aa7ef500-99ec-11ea-9a40-b52b383f99f0.png)

We need to let the widget know the URL of our site so it knows where to go to get user data and confirm they're able to log in. Back over to Netlify, you can get that from the Identity tab:

![Netlify site URL](https://user-images.githubusercontent.com/300/82387937-28430080-99ed-11ea-91b7-a4e10f14aa83.png)

You need the protocol and domain, not the rest of the path. Paste that into the modal and click that **Set site's URL** button. The modal should reload and now show a real login box:

![Netlify identity widget login](https://user-images.githubusercontent.com/300/82388116-97205980-99ed-11ea-8fb4-13436ee8e746.png)

Before we can log in, remember that confirmation email from Netlify? Go find that and click the **Accept the invite** link. That will bring you to your site live in production, where nothing will happen. But if you look at the URL it will end in something like `#invite_token=6gFSXhugtHCXO5Whlc5V`. Copy that (including the `#`) and appened it to your localhost URL: http://localhost:8910/#invite_token=6gFSXhugtHCXO5Whlc5Vg Hit Enter, then go back into the URL and hit Enter again to get it to actually reload the page. Now the modal will show **Complete your signup** and give you the ability to set your password:

![Netlify identity set password](https://user-images.githubusercontent.com/300/82388369-54ab4c80-99ee-11ea-920e-9df10ee0cac2.png)

Once you do that the modal should update and say that you're logged in! It worked! Click the X in the upper right to close the modal.

> We know that invite acceptance flow is less than ideal. The good news is that once you deploy your site again with authentication, future invites will work automaticallyâ€”the link will go to production which will now have the code needed to launch the modal and let you accept the invite.

We've got no indication on our actual site that we're logged in, however. How about changing the **Log In** button to be **Log Out** when you're authenticated:

```javascript{7,23-24}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'
import { useAuth } from '@redwoodjs/auth'

const BlogLayout = ({ children }) => {
  const { logIn, logOut, isAuthenticated } = useAuth()

  return (
    <div>
      <h1>
        <Link to={routes.home()}>Redwood Blog</Link>
      </h1>
      <nav>
        <ul>
          <li>
            <Link to={routes.about()}>About</Link>
          </li>
          <li>
            <Link to={routes.contact()}>Contact</Link>
          </li>
          <li>
            <a href="#" onClick={isAuthenticated ? logOut : logIn}>
              {isAuthenticated ? 'Log Out' : 'Log In'}
            </a>
          </li>
        </ul>
      </nav>
      <main>{children}</main>
    </div>
  )
}

export default BlogLayout
```

`useAuth()` provides a couple more helpers for us, in this case `isAuthenticated` which will return `true` or `false` based on your login status, and `logOut()` which will log the user out. Now clicking **Log Out** should log you out and change the link to **Log In** which you can click to open the modal and log back in again.

When you *are* logged in, you should be able to access the admin pages again: http://localhost:8910/admin/posts

> If you start working on another Redwood app that uses Netlify Identity you'll need to manually clear out your Local Storage which is where the site URL is stored that you entered the first time you saw the modal. Local Storage is tied to your domain and port, which by default will be the same for any Redwood app when developing locally. You can clear your Local Storage in Chrome by going to the Web Inspector, the **Application** tab, and then on the left open up **Local Storage** and click on http://localhost:8910. You'll see the keys stored on the right and can delete them all.

One more touch: let's show the email address of the user that's logged in. We can get the `currentUser` from `useAuth()` and it will contain the data that our third party authentication library is storing about the currently logged in user:

```javascript{7,27}
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from '@redwoodjs/router'
import { useAuth } from '@redwoodjs/auth'

const BlogLayout = ({ children }) => {
  const { logIn, logOut, isAuthenticated, currentUser } = useAuth()

  return (
    <div>
      <h1>
        <Link to={routes.home()}>Redwood Blog</Link>
      </h1>
      <nav>
        <ul>
          <li>
            <Link to={routes.about()}>About</Link>
          </li>
          <li>
            <Link to={routes.contact()}>Contact</Link>
          </li>
          <li>
            <a href="#" onClick={isAuthenticated ? logOut : logIn}>
              {isAuthenticated ? 'Log Out' : 'Log In'}
            </a>
          </li>
          {isAuthenticated && <li>{currentUser.email}</li>}
        </ul>
      </nav>
      <main>{children}</main>
    </div>
  )
}

export default BlogLayout
```

![Logged in email](https://user-images.githubusercontent.com/300/82389433-05b2e680-99f1-11ea-9d01-456cad508c80.png)

> Check out the settings for Identity over at Netlify for more options, including allowing users to create accounts rather than having to be invited, add third party login buttons for Bitbucket, GitHub, GitLab and Google, receive webhooks when someone logs in, and more!

Believe it or not, that's it! Authentication with Redwood is a breeze and we're just getting started. Expect more magic soon!

> If you inspect the contents of `currentUser` you'll see it contains an array called `roles`. On the Netlify Identity dashboard you can give your user a collection of roles, which are just strings like "admin" or "guest". Using this array of roles you *could* create a very rudimentary role-based authentication system. Unless you are in dire need of this simple role checking, we recommend waiting for the Redwood solution, coming soon!

## Wrapping Up

You made it! If you really went through the whole tutorial: congratulations! If you just skipped ahead to this page to try and get a free congratulations: tsk, tsk!

That was potentially a lot of new concepts to absorb all at once so don't feed bad if all of it didn't fully sink in. React, GraphQL, Prisma, serverless functions...so many things! Even those of us working on the framework are heading over to Google multiple times per day to figure out how to get these things to work together.

As an anonymous Twitter user once mused: "If you enjoy feeling like both the smartest person on earth and the dumbest person in history within a span of 24 hours, programming may be the career for you!"

### What's Next?

Want to add some more features to your app? Check out some of our Cookbook recipies like [calling to a third party API](/cookbook/using-a-third-party-api) and [deploying an app without an API at all](/cookbook/disable-api-database). Have you grown out of SQLite and want to [install Postgres locally](/docs/local-postgres-setup)? We've also got lots of [guides](/docs/introduction) for more info on Redwood's internals.

### Roadmap

Check out our [Roadmap](https://redwoodjs.com/roadmap) to see where we're headed and how we're going to get there.
If you're interested in helping with anything you see, just let us know over on the [RedwoodJS Forum](https://community.redwoodjs.com/) and we'll be happy to get you set up.
We want to hit `1.0` by the end of the year. And with your help, we think we can do it!

### Help Us!

What did you think of Redwood? Is it the Next Step for JS frameworks? What can it do better? We've got a lot more planned. Want to help us build these upcoming features?

- [Open a PR](https://github.com/redwoodjs/redwood/pulls)
- [Write some docs](/docs/introduction)
- [Join the community](https://community.redwoodjs.com)

Thanks for following along. Now go out and build something amazing!
